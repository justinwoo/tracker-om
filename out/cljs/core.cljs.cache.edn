;; Analyzed by ClojureScript 0.0-2657
{:defs {->PersistentHashSet {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :name cljs.core/->PersistentHashSet, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([meta hash-map __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentHashSet, :variadic false, :max-fixed-arity 3}), :line 7243, :end-line 7243, :max-fixed-arity 3, :fn-var true, :arglists (quote ([meta hash-map __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :test true}, ->ExceptionInfo {:protocol-inline nil, :protocols #{}, :name cljs.core/->ExceptionInfo, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([message data cause]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ExceptionInfo, :variadic false, :max-fixed-arity 3}), :line 9047, :end-line 9047, :max-fixed-arity 3, :fn-var true, :arglists (quote ([message data cause])), :skip-protocol-flag nil, :test true}, js->clj {:protocol-inline nil, :name cljs.core/js->clj, :variadic true, :file "out/cljs/core.cljs", :end-column 15, :method-params ([x] [x opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj any cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 1} {:tag #{nil clj any cljs.core/MetaFn clj-nil}, :variadic true, :max-fixed-arity 1}), :line 8543, :end-line 8543, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x] [x & opts])), :doc "Recursively transforms JavaScript arrays into ClojureScript\n  vectors, and JavaScript objects into ClojureScript maps.  With\n  option ':keywordize-keys true' will convert object fields from\n  strings to keywords.", :test true}, sort-by {:protocol-inline nil, :name cljs.core/sort-by, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([keyfn coll] [keyfn comp coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{seq cljs.core/IList}, :variadic false, :max-fixed-arity 2} {:tag #{seq cljs.core/IList}, :variadic false, :max-fixed-arity 3}), :line 1658, :end-line 1658, :max-fixed-arity 3, :fn-var true, :arglists (quote ([keyfn coll] [keyfn comp coll])), :doc "Returns a sorted sequence of the items in coll, where the sort\n   order is determined by comparing (keyfn item).  Comp can be\n   boolean-valued comparison funcion, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :test true}, ITransientAssociative {:protocol-symbol true, :name cljs.core/ITransientAssociative, :file "out/cljs/core.cljs", :end-column 36, :column 1, :line 369, :protocol-info {:methods {-assoc! [[tcoll key val]]}}, :info nil, :end-line 369, :impls #{cljs.core/TransientVector cljs.core/TransientHashMap cljs.core/TransientArrayMap}, :test true}, chunk-first {:protocol-inline nil, :name cljs.core/chunk-first, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 2672, :end-line 2672, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :test true}, m3-hash-int {:protocol-inline nil, :name cljs.core/m3-hash-int, :variadic false, :file "out/cljs/core.cljs", :end-column 27, :method-params ([in]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil number}, :variadic false, :max-fixed-arity 1}), :line 472, :ret-tag number, :end-line 472, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([in])), :test true}, stepper {:protocol-inline nil, :name cljs.core/stepper, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([xform iter]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 3069, :end-line 3069, :max-fixed-arity 2, :fn-var true, :arglists (quote ([xform iter])), :test true}, pr-str* {:protocol-inline nil, :name cljs.core/pr-str*, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 420, :end-line 420, :max-fixed-arity 1, :fn-var true, :arglists (quote ([obj])), :doc "Support so that collections can implement toString without\n   loading all the printing machinery.", :test true}, eduction {:protocol-inline nil, :name cljs.core/eduction, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([xform coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/Eduction, :variadic false, :max-fixed-arity 2}), :line 8489, :end-line 8489, :max-fixed-arity 2, :fn-var true, :arglists (quote ([xform coll])), :doc "Returns a reducible/iterable/seqable application of\n  the transducer to the items in coll. Note that these applications\t\n  will be performed every time iterator/seq/reduce is called.", :test true}, tree-seq {:protocol-inline nil, :name cljs.core/tree-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([branch? children root]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 3}), :line 3898, :end-line 3898, :max-fixed-arity 3, :fn-var true, :arglists (quote ([branch? children root])), :doc "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n   branch? must be a fn of one arg that returns true if passed a node\n   that can have children (but may not).  children must be a fn of one\n   arg that returns a sequence of the children. Will only be called on\n   nodes for which branch? returns true. Root is the root node of the\n  tree.", :test true}, unchecked-remainder-int {:protocol-inline nil, :name cljs.core/unchecked-remainder-int, :variadic false, :file "out/cljs/core.cljs", :end-column 31, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 1947, :end-line 1947, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :test true}, seq {:protocol-inline nil, :name cljs.core/seq, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/IndexedSeq clj-or-nil clj-nil}, :variadic false, :max-fixed-arity 1}), :line 645, :ret-tag seq, :end-line 645, :max-fixed-arity 1, :tag seq, :fn-var true, :arglists (quote ([coll])), :doc "Returns a seq on the collection. If the collection is\n  empty, returns nil.  (seq nil) returns nil. seq also works on\n  Strings.", :test true}, Volatile {:num-fields 1, :protocols #{cljs.core/IVolatile cljs.core/IDeref}, :name cljs.core/Volatile, :file "out/cljs/core.cljs", :end-column 19, :type true, :column 10, :line 3515, :record false, :end-line 3515, :skip-protocol-flag #{cljs.core/IDeref}}, reduce {:protocol-inline nil, :name cljs.core/reduce, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([f coll] [f val coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 1692, :end-line 1692, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f coll] [f val coll])), :doc "f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called.", :test true}, INIT {:file "out/cljs/core.cljs", :line 3018, :column 1, :end-line 3018, :end-column 11, :test true, :name cljs.core/INIT}, contains? {:protocol-inline nil, :name cljs.core/contains?, :variadic false, :file "out/cljs/core.cljs", :end-column 26, :method-params ([coll v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 1555, :ret-tag boolean, :end-line 1555, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([coll v])), :doc "Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and arrays, this tests if the numeric key is within the\n  range of indexes. 'contains?' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also 'some'.", :test true}, every? {:protocol-inline nil, :name cljs.core/every?, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 3220, :ret-tag boolean, :end-line 3220, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns true if (pred x) is logical true for every x in coll, else\n  false.", :test true}, ->ES6IteratorSeq {:protocol-inline nil, :protocols #{cljs.core/ISeq cljs.core/ISeqable}, :name cljs.core/->ES6IteratorSeq, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([value iter _rest]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ES6IteratorSeq, :variadic false, :max-fixed-arity 3}), :line 734, :end-line 734, :max-fixed-arity 3, :fn-var true, :arglists (quote ([value iter _rest])), :skip-protocol-flag #{cljs.core/ISeq cljs.core/ISeqable}, :test true}, Var {:num-fields 3, :protocols #{cljs.core/IMeta cljs.core/IDeref}, :name cljs.core/Var, :file "out/cljs/core.cljs", :end-column 14, :type true, :column 10, :line 626, :record false, :end-line 626, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IDeref}}, keep-indexed {:protocol-inline nil, :name cljs.core/keep-indexed, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([f] [f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:variadic false, :max-fixed-arity 2}), :line 3537, :end-line 3537, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f] [f coll])), :doc "Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a stateful transducer when no collection is\n  provided.", :test true}, ->PersistentQueueSeq {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/->PersistentQueueSeq, :variadic false, :file "out/cljs/core.cljs", :end-column 29, :method-params ([meta front rear __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentQueueSeq, :variadic false, :max-fixed-arity 4}), :line 4781, :end-line 4781, :max-fixed-arity 4, :fn-var true, :arglists (quote ([meta front rear __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}, :test true}, subs {:protocol-inline nil, :name cljs.core/subs, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([s start] [s start end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:tag any, :variadic false, :max-fixed-arity 3}), :line 2133, :end-line 2133, :max-fixed-arity 3, :fn-var true, :arglists (quote ([s start] [s start end])), :doc "Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive.", :test true}, set {:protocol-inline nil, :name cljs.core/set, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 7474, :end-line 7474, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a set of the distinct elements of coll.", :test true}, compare-indexed {:protocol-inline nil, :private true, :name cljs.core/compare-indexed, :variadic false, :file "out/cljs/core.cljs", :end-column 33, :method-params ([xs ys] [xs ys len n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2} {:tag number, :variadic false, :max-fixed-arity 4}), :line 1613, :end-line 1613, :max-fixed-arity 4, :fn-var true, :arglists (quote ([xs ys] [xs ys len n])), :doc "Compare indexed collection.", :test true}, take-last {:protocol-inline nil, :name cljs.core/take-last, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag seq, :variadic false, :max-fixed-arity 2}), :line 3751, :end-line 3751, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n coll])), :doc "Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec.", :test true}, IndexedSeq {:num-fields 2, :protocols #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IReduce}, :name cljs.core/IndexedSeq, :file "out/cljs/core.cljs", :end-column 21, :type true, :column 10, :line 940, :record false, :declared true, :end-line 940, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ICloneable cljs.core/ISequential cljs.core/IReduce}, :test true}, bit-set {:protocol-inline nil, :name cljs.core/bit-set, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2050, :end-line 2050, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Set bit at index n", :test true}, string-hash-cache-count {:file "out/cljs/core.cljs", :line 499, :column 1, :end-line 499, :end-column 30, :test true, :name cljs.core/string-hash-cache-count}, ->Eduction {:protocol-inline nil, :protocols #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/ISequential cljs.core/IReduce}, :name cljs.core/->Eduction, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([xform coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Eduction, :variadic false, :max-fixed-arity 2}), :line 8474, :end-line 8474, :max-fixed-arity 2, :fn-var true, :arglists (quote ([xform coll])), :skip-protocol-flag #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/ISequential cljs.core/IReduce}, :test true}, tree-map-add {:protocol-inline nil, :private true, :name cljs.core/tree-map-add, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([comp tree k v found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil cljs.core/RedNode}, :variadic false, :max-fixed-arity 5}), :line 6761, :end-line 6761, :max-fixed-arity 5, :fn-var true, :arglists (quote ([comp tree k v found])), :test true}, ->ES6SetEntriesIterator {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->ES6SetEntriesIterator, :variadic false, :file "out/cljs/core.cljs", :end-column 32, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ES6SetEntriesIterator, :variadic false, :max-fixed-arity 1}), :line 5072, :end-line 5072, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :skip-protocol-flag nil, :test true}, -with-meta {:protocol-inline nil, :protocol cljs.core/IWithMeta, :name cljs.core/-with-meta, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([o meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 306, :ret-tag clj, :end-line 307, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([o meta])), :test true}, reset-cache {:protocol-inline nil, :private true, :name cljs.core/reset-cache, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([method-cache method-table cached-hierarchy hierarchy]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 4}), :line 8747, :end-line 8747, :max-fixed-arity 4, :fn-var true, :arglists (quote ([method-cache method-table cached-hierarchy hierarchy])), :test true}, ->PersistentArrayMapIterator {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->PersistentArrayMapIterator, :variadic false, :file "out/cljs/core.cljs", :end-column 37, :method-params ([arr i cnt]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentArrayMapIterator, :variadic false, :max-fixed-arity 3}), :line 5222, :end-line 5222, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr i cnt])), :skip-protocol-flag nil, :test true}, PersistentArrayMapIterator {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/PersistentArrayMapIterator, :file "out/cljs/core.cljs", :end-column 37, :type true, :column 10, :line 5222, :record false, :end-line 5222, :skip-protocol-flag nil}, butlast {:protocol-inline nil, :name cljs.core/butlast, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag seq, :variadic false, :max-fixed-arity 1}), :line 7538, :end-line 7538, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :test true}, tail-off {:protocol-inline nil, :private true, :name cljs.core/tail-off, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([pv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 4071, :end-line 4071, :max-fixed-arity 1, :fn-var true, :arglists (quote ([pv])), :test true}, unchecked-subtract-int {:protocol-inline nil, :name cljs.core/unchecked-subtract-int, :variadic true, :file "out/cljs/core.cljs", :end-column 38, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 1957, :ret-tag number, :end-line 1957, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :test true}, -iterator {:protocol-inline nil, :protocol cljs.core/IIterable, :name cljs.core/-iterator, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 410, :end-line 411, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, take-nth {:protocol-inline nil, :name cljs.core/take-nth, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([n] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 7786, :end-line 7786, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n] [n coll])), :doc "Returns a lazy seq of every nth item in coll.  Returns a stateful\n  transducer when no collection is provided.", :test true}, first {:protocol-inline nil, :name cljs.core/first, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 668, :end-line 668, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the first item in the collection. Calls seq on its\n  argument. If coll is nil, returns nil.", :test true}, native-satisfies? {:protocol-inline nil, :name cljs.core/native-satisfies?, :variadic false, :file "out/cljs/core.cljs", :end-column 34, :method-params ([p x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 113, :ret-tag boolean, :end-line 113, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([p x])), :doc "Internal - do not use!", :test true}, seq? {:protocol-inline nil, :name cljs.core/seq?, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1529, :ret-tag boolean, :end-line 1529, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([s])), :doc "Return true if s satisfies ISeq", :test true}, -global-hierarchy {:file "out/cljs/core.cljs", :line 8637, :column 1, :end-line 8637, :end-column 34, :private true, :test true, :name cljs.core/-global-hierarchy}, UUID {:num-fields 1, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter}, :name cljs.core/UUID, :file "out/cljs/core.cljs", :end-column 15, :type true, :column 10, :line 9027, :record false, :end-line 9027, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter}}, -sorted-seq-from {:protocol-inline nil, :protocol cljs.core/ISorted, :name cljs.core/-sorted-seq-from, :variadic false, :file "out/cljs/core.cljs", :end-column 26, :method-params ([coll k ascending?]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 336, :ret-tag clj, :end-line 338, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([coll k ascending?])), :test true}, println-str {:protocol-inline nil, :name cljs.core/println-str, :variadic true, :file "out/cljs/core.cljs", :end-column 19, :method-params ([objs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil string}, :variadic true, :max-fixed-arity 0}), :line 8185, :end-line 8185, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& objs])), :doc "println to a string, returning it", :test true}, linear-traversal-nth {:protocol-inline nil, :private true, :name cljs.core/linear-traversal-nth, :variadic false, :file "out/cljs/core.cljs", :end-column 29, :method-params ([coll n] [coll n not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 2} {:tag #{nil any clj-nil}, :variadic false, :max-fixed-arity 3}), :line 1165, :end-line 1165, :max-fixed-arity 3, :fn-var true, :arglists (quote ([coll n] [coll n not-found])), :test true}, iterate {:protocol-inline nil, :added "1.0", :name cljs.core/iterate, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([f x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/Cons, :variadic false, :max-fixed-arity 2}), :line 3812, :end-line 3812, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f x])), :doc "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects", :test true}, -empty {:protocol-inline nil, :protocol cljs.core/IEmptyableCollection, :name cljs.core/-empty, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 250, :end-line 251, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, newline {:protocol-inline nil, :name cljs.core/newline, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 1}), :line 8143, :end-line 8143, :max-fixed-arity 1, :fn-var true, :arglists (quote ([opts])), :test true}, ILookup {:protocol-symbol true, :name cljs.core/ILookup, :file "out/cljs/core.cljs", :end-column 22, :column 1, :line 271, :protocol-info {:methods {-lookup [[o k] [o k not-found]]}}, :info nil, :end-line 271, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/TransientVector cljs.core/PersistentArrayMap cljs.core/BlackNode cljs.core/Subvec cljs.core/TransientHashMap cljs.core/PersistentVector cljs.core/TransientArrayMap cljs.core/TransientHashSet cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet cljs.core/RedNode}, :test true}, -chunked-rest {:protocol-inline nil, :protocol cljs.core/IChunkedSeq, :name cljs.core/-chunked-rest, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 388, :end-line 390, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, write-all {:protocol-inline nil, :name cljs.core/write-all, :variadic true, :file "out/cljs/core.cljs", :end-column 17, :method-params ([writer ss]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic true, :max-fixed-arity 1}), :line 8006, :end-line 8006, :max-fixed-arity 1, :fn-var true, :arglists (quote ([writer & ss])), :test true}, fn? {:protocol-inline nil, :name cljs.core/fn?, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1330, :ret-tag boolean, :end-line 1330, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([f])), :test true}, -prefer-method {:protocol-inline nil, :protocol cljs.core/IMultiFn, :name cljs.core/-prefer-method, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([mf dispatch-val dispatch-val-y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 8799, :end-line 8803, :max-fixed-arity 3, :fn-var true, :arglists (quote ([mf dispatch-val dispatch-val-y])), :test true}, -assoc {:protocol-inline nil, :protocol cljs.core/IAssociative, :name cljs.core/-assoc, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([coll k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 274, :ret-tag clj, :end-line 277, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([coll k v])), :test true}, doall {:protocol-inline nil, :name cljs.core/doall, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([coll] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1} {:variadic false, :max-fixed-arity 2}), :line 7923, :end-line 7923, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll] [n coll])), :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. doall can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, retains the head and returns it, thus causing the entire\n  seq to reside in memory at one time.", :test true}, keyword-identical? {:protocol-inline nil, :name cljs.core/keyword-identical?, :variadic false, :file "out/cljs/core.cljs", :end-column 35, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 2450, :ret-tag boolean, :end-line 2450, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x y])), :test true}, pv-aset {:protocol-inline nil, :private true, :name cljs.core/pv-aset, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([node idx val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 3}), :line 4065, :end-line 4065, :max-fixed-arity 3, :fn-var true, :arglists (quote ([node idx val])), :test true}, prefers {:protocol-inline nil, :name cljs.core/prefers, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([multifn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 9021, :end-line 9021, :max-fixed-arity 1, :fn-var true, :arglists (quote ([multifn])), :doc "Given a multimethod, returns a map of preferred value -> set of other values", :test true}, -js->clj {:protocol-inline nil, :protocol cljs.core/IEncodeClojure, :name cljs.core/-js->clj, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([x options]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 8540, :end-line 8541, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x options])), :test true}, LazySeq {:num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/LazySeq, :file "out/cljs/core.cljs", :end-column 18, :type true, :column 10, :line 2480, :record false, :end-line 2480, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, dedupe {:protocol-inline nil, :name cljs.core/dedupe, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([] [coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 0} {:tag any, :variadic false, :max-fixed-arity 1}), :line 8447, :end-line 8447, :max-fixed-arity 1, :fn-var true, :arglists (quote ([] [coll])), :doc "Returns a lazy sequence removing consecutive duplicates in coll.\n  Returns a transducer when no collection is provided.", :test true}, unchecked-editable-array-for {:protocol-inline nil, :private true, :name cljs.core/unchecked-editable-array-for, :variadic false, :file "out/cljs/core.cljs", :end-column 37, :method-params ([tv i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 4632, :end-line 4632, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tv i])), :test true}, ->ES6Iterator {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->ES6Iterator, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ES6Iterator, :variadic false, :max-fixed-arity 1}), :line 720, :end-line 720, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :skip-protocol-flag nil, :test true}, VectorNode {:num-fields 2, :protocols #{}, :name cljs.core/VectorNode, :file "out/cljs/core.cljs", :end-column 21, :type true, :column 10, :line 4057, :record false, :end-line 4057, :skip-protocol-flag nil}, dissoc {:protocol-inline nil, :name cljs.core/dissoc, :variadic true, :file "out/cljs/core.cljs", :end-column 14, :method-params ([coll] [coll k] [coll k ks]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1} {:tag #{clj clj-nil}, :variadic false, :max-fixed-arity 2} {:tag #{clj clj-nil}, :variadic true, :max-fixed-arity 2}), :line 1316, :end-line 1316, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll] [coll k] [coll k & ks])), :doc "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s).", :test true}, atom {:file "out/cljs/core.cljs", :line 5492, :column 1, :end-line 5492, :end-column 73, :declared true, :test true, :name cljs.core/atom}, bit-shift-right {:protocol-inline nil, :name cljs.core/bit-shift-right, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2064, :end-line 2064, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Bitwise shift right", :test true}, *clojurescript-version* {:file "out/cljs/core.cljs", :line 16, :column 1, :end-line 16, :end-column 30, :test true, :name cljs.core/*clojurescript-version*}, -first {:protocol-inline nil, :protocol cljs.core/ISeq, :name cljs.core/-first, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 264, :end-line 265, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, peek {:protocol-inline nil, :name cljs.core/peek, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 1402, :end-line 1402, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil.", :test true}, IKVReduce {:protocol-symbol true, :name cljs.core/IKVReduce, :file "out/cljs/core.cljs", :end-column 24, :column 1, :line 312, :protocol-info {:methods {-kv-reduce [[coll f init]]}}, :info nil, :end-line 312, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/PersistentArrayMap cljs.core/PersistentVector cljs.core/PersistentTreeMap}, :test true}, aget {:protocol-inline nil, :name cljs.core/aget, :variadic true, :file "out/cljs/core.cljs", :end-column 12, :method-params ([array i] [array i idxs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 2} {:tag any, :variadic true, :max-fixed-arity 2}), :line 181, :end-line 181, :max-fixed-arity 2, :fn-var true, :arglists (quote ([array i] [array i & idxs])), :doc "Returns the value at the index.", :test true}, PersistentTreeMapSeq {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/PersistentTreeMapSeq, :file "out/cljs/core.cljs", :end-column 31, :type true, :column 10, :line 6355, :record false, :end-line 6355, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -write {:protocol-inline nil, :protocol cljs.core/IWriter, :name cljs.core/-write, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([writer s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 342, :end-line 343, :max-fixed-arity 2, :fn-var true, :arglists (quote ([writer s])), :test true}, iter {:protocol-inline nil, :name cljs.core/iter, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any cljs.core/t11986 cljs.core/StringIter cljs.core/ArrayIter cljs.core/SeqIter}, :variadic false, :max-fixed-arity 1}), :line 3042, :end-line 3042, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, mk-bound-fn {:protocol-inline nil, :name cljs.core/mk-bound-fn, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([sc test key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 3}), :line 7640, :end-line 7640, :max-fixed-arity 3, :fn-var true, :arglists (quote ([sc test key])), :test true}, last {:protocol-inline nil, :name cljs.core/last, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 1105, :end-line 1105, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Return the last item in coll, in linear time", :test true}, pr {:protocol-inline nil, :name cljs.core/pr, :variadic true, :file "out/cljs/core.cljs", :end-column 10, :method-params ([objs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic true, :max-fixed-arity 0}), :line 8158, :end-line 8158, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& objs])), :doc "Prints the object(s) using string-print.  Prints the\n  object(s), separated by spaces if there is more than one.\n  By default, pr and prn print in a way that objects can be\n  read by the reader", :test true}, tree-map-seq-push {:protocol-inline nil, :private true, :name cljs.core/tree-map-seq-push, :variadic false, :file "out/cljs/core.cljs", :end-column 26, :method-params ([node stack ascending?]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 3}), :line 6348, :end-line 6348, :max-fixed-arity 3, :fn-var true, :arglists (quote ([node stack ascending?])), :test true}, namespace {:protocol-inline nil, :name cljs.core/namespace, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag string, :variadic false, :max-fixed-arity 1}), :line 2458, :end-line 2458, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns the namespace String of a symbol or keyword, or nil if not present.", :test true}, obj-map {:protocol-inline nil, :name cljs.core/obj-map, :variadic true, :file "out/cljs/core.cljs", :end-column 15, :method-params ([keyvals]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic true, :max-fixed-arity 0}), :line 7033, :end-line 7033, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new object map with supplied mappings.", :test true}, Reduced {:num-fields 1, :protocols #{cljs.core/IDeref}, :name cljs.core/Reduced, :file "out/cljs/core.cljs", :end-column 18, :type true, :column 10, :line 827, :record false, :end-line 827, :skip-protocol-flag #{cljs.core/IDeref}}, -conj {:protocol-inline nil, :protocol cljs.core/ICollection, :name cljs.core/-conj, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([coll o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 253, :ret-tag clj, :end-line 254, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([coll o])), :test true}, NodeSeq {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/NodeSeq, :file "out/cljs/core.cljs", :end-column 18, :type true, :column 10, :line 5986, :record false, :end-line 5986, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, = {:protocol-inline nil, :name cljs.core/=, :variadic true, :file "out/cljs/core.cljs", :end-column 18, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1} {:tag boolean, :variadic false, :max-fixed-arity 2} {:tag boolean, :variadic true, :max-fixed-arity 2}), :line 701, :ret-tag boolean, :end-line 701, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Equality. Returns true if x equals y, false if not. Compares\n  numbers and collections in a type-independent manner.  Clojure's immutable data\n  structures define -equiv (and thus =) as a value, not an identity,\n  comparison.", :test true}, ITransientMap {:protocol-symbol true, :name cljs.core/ITransientMap, :file "out/cljs/core.cljs", :end-column 28, :column 1, :line 372, :protocol-info {:methods {-dissoc! [[tcoll key]]}}, :info nil, :end-line 372, :impls #{cljs.core/TransientHashMap cljs.core/TransientArrayMap}, :test true}, push-tail {:protocol-inline nil, :private true, :name cljs.core/push-tail, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([pv level parent tailnode]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/VectorNode, :variadic false, :max-fixed-arity 4}), :line 4087, :end-line 4087, :max-fixed-arity 4, :fn-var true, :arglists (quote ([pv level parent tailnode])), :test true}, take {:protocol-inline nil, :name cljs.core/take, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([n] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 3698, :end-line 3698, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n] [n coll])), :doc "Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.  Returns a stateful transducer when\n  no collection is provided.", :test true}, vector? {:protocol-inline nil, :name cljs.core/vector?, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1474, :ret-tag boolean, :end-line 1474, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies IVector", :test true}, bitmap-indexed-node-index {:protocol-inline nil, :private true, :name cljs.core/bitmap-indexed-node-index, :variadic false, :file "out/cljs/core.cljs", :end-column 34, :method-params ([bitmap bit]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 5518, :end-line 5518, :max-fixed-arity 2, :fn-var true, :arglists (quote ([bitmap bit])), :test true}, boolean {:protocol-inline nil, :name cljs.core/boolean, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1541, :ret-tag boolean, :end-line 1541, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :test true}, IChunk {:protocol-symbol true, :name cljs.core/IChunk, :file "out/cljs/core.cljs", :end-column 21, :column 1, :line 385, :protocol-info {:methods {-drop-first [[coll]]}}, :info nil, :end-line 385, :impls #{cljs.core/ArrayChunk}, :test true}, bit-shift-left {:protocol-inline nil, :name cljs.core/bit-shift-left, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2060, :end-line 2060, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Bitwise shift left", :test true}, rand-int {:protocol-inline nil, :name cljs.core/rand-int, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 8610, :end-line 8610, :max-fixed-arity 1, :fn-var true, :arglists (quote ([n])), :doc "Returns a random integer between 0 (inclusive) and n (exclusive).", :test true}, aclone {:protocol-inline nil, :name cljs.core/aclone, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1}), :line 164, :end-line 164, :max-fixed-arity 1, :fn-var true, :arglists (quote ([arr])), :doc "Returns a javascript array, cloned from the passed in array", :test true}, BlackNode {:num-fields 5, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/BlackNode, :file "out/cljs/core.cljs", :end-column 20, :type true, :column 10, :line 6514, :record false, :declared true, :end-line 6514, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :test true}, vreset! {:protocol-inline nil, :name cljs.core/vreset!, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([vol newval]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 3532, :end-line 3532, :max-fixed-arity 2, :fn-var true, :arglists (quote ([vol newval])), :doc "Sets the value of volatile to newval without regard for the\n   current value. Returns newval.", :test true}, chunk {:protocol-inline nil, :name cljs.core/chunk, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 2669, :end-line 2669, :max-fixed-arity 1, :fn-var true, :arglists (quote ([b])), :test true}, dec {:protocol-inline nil, :name cljs.core/dec, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 1854, :end-line 1854, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a number one less than num.", :test true}, map {:protocol-inline nil, :name cljs.core/map, :variadic true, :file "out/cljs/core.cljs", :end-column 11, :method-params ([f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 colls]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 3} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 4} {:tag cljs.core/LazySeq, :variadic true, :max-fixed-arity 4}), :line 3651, :end-line 3651, :max-fixed-arity 4, :fn-var true, :arglists (quote ([f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls])), :doc "Returns a lazy sequence consisting of the result of applying f to\n  the set of first items of each coll, followed by applying f to the\n  set of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments. Returns a transducer when\n  no collection is provided.", :test true}, juxt {:protocol-inline nil, :name cljs.core/juxt, :variadic true, :file "out/cljs/core.cljs", :end-column 12, :method-params ([f] [f g] [f g h] [f g h fs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag function, :variadic false, :max-fixed-arity 2} {:tag function, :variadic false, :max-fixed-arity 3} {:tag function, :variadic true, :max-fixed-arity 3}), :line 7874, :end-line 7874, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f] [f g] [f g h] [f g h & fs])), :doc "Takes a set of functions and returns a fn that is the juxtaposition\n  of those fns.  The returned fn takes a variable number of args, and\n  returns a vector containing the result of applying each fn to the\n  args (left-to-right).\n  ((juxt a b c) x) => [(a x) (b x) (c x)]", :test true}, < {:protocol-inline nil, :name cljs.core/<, :variadic true, :file "out/cljs/core.cljs", :end-column 18, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1} {:tag boolean, :variadic false, :max-fixed-arity 2} {:tag boolean, :variadic true, :max-fixed-arity 2}), :line 1806, :ret-tag boolean, :end-line 1806, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically increasing order,\n  otherwise false.", :test true}, inode-kv-reduce {:protocol-inline nil, :private true, :name cljs.core/inode-kv-reduce, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([arr f init]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 5535, :end-line 5535, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr f init])), :test true}, obj-map->hash-map {:protocol-inline nil, :private true, :name cljs.core/obj-map->hash-map, :variadic false, :file "out/cljs/core.cljs", :end-column 26, :method-params ([m k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{clj cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 3}), :line 4924, :end-line 4924, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m k v])), :test true}, test {:protocol-inline nil, :name cljs.core/test, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/Keyword, :variadic false, :max-fixed-arity 1}), :line 9099, :end-line 9099, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v])), :doc "test [v] finds fn at key :test in var metadata and calls it,\n  presuming failure will throw exception", :test true}, rest {:protocol-inline nil, :name cljs.core/rest, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 679, :ret-tag seq, :end-line 679, :max-fixed-arity 1, :tag seq, :fn-var true, :arglists (quote ([coll])), :doc "Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument.", :test true}, ex-data {:protocol-inline nil, :name cljs.core/ex-data, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([ex]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 9062, :end-line 9062, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ex])), :doc "Alpha - subject to change.\n  Returns exception data (a map) if ex is an ExceptionInfo.\n  Otherwise returns nil.", :test true}, PersistentArrayMapSeq {:num-fields 3, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/PersistentArrayMapSeq, :file "out/cljs/core.cljs", :end-column 32, :type true, :column 10, :line 5161, :record false, :end-line 5161, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -drop-first {:protocol-inline nil, :protocol cljs.core/IChunk, :name cljs.core/-drop-first, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 385, :end-line 386, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, isa? {:protocol-inline nil, :name cljs.core/isa?, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([child parent] [h child parent]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2} {:tag boolean, :variadic false, :max-fixed-arity 3}), :line 8647, :ret-tag boolean, :end-line 8647, :max-fixed-arity 3, :tag boolean, :fn-var true, :arglists (quote ([child parent] [h child parent])), :doc "Returns true if (= child parent), or child is directly or indirectly derived from\n  parent, either via a JavaScript type inheritance relationship or a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy", :test true}, -clone {:protocol-inline nil, :protocol cljs.core/ICloneable, :name cljs.core/-clone, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 244, :ret-tag clj, :end-line 245, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([value])), :test true}, ES6IteratorSeq {:num-fields 3, :protocols #{cljs.core/ISeq cljs.core/ISeqable}, :name cljs.core/ES6IteratorSeq, :file "out/cljs/core.cljs", :end-column 25, :type true, :column 10, :line 734, :record false, :end-line 734, :skip-protocol-flag #{cljs.core/ISeq cljs.core/ISeqable}}, ->NeverEquiv {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/Object}, :name cljs.core/->NeverEquiv, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/NeverEquiv, :variadic false, :max-fixed-arity 0}), :line 4879, :end-line 4879, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :skip-protocol-flag #{cljs.core/IEquiv}, :test true}, re-seq {:protocol-inline nil, :name cljs.core/re-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([re s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/LazySeq clj-nil}, :variadic false, :max-fixed-arity 2}), :line 7968, :end-line 7968, :max-fixed-arity 2, :fn-var true, :arglists (quote ([re s])), :doc "Returns a lazy sequence of successive matches of re in s.", :test true}, make-hierarchy {:protocol-inline nil, :name cljs.core/make-hierarchy, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/IMap, :variadic false, :max-fixed-arity 0}), :line 8633, :end-line 8633, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Creates a hierarchy object for use with derive, isa? etc.", :test true}, Symbol {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :name cljs.core/Symbol, :file "out/cljs/core.cljs", :end-column 17, :type true, :column 10, :line 581, :record false, :declared true, :end-line 581, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :test true}, tv-push-tail {:protocol-inline nil, :private true, :name cljs.core/tv-push-tail, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([tv level parent tail-node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil cljs.core/VectorNode}, :variadic false, :max-fixed-arity 4}), :line 4606, :end-line 4606, :max-fixed-arity 4, :fn-var true, :arglists (quote ([tv level parent tail-node])), :test true}, -reduce {:protocol-inline nil, :protocol cljs.core/IReduce, :name cljs.core/-reduce, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([coll f] [coll f start]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:tag any, :variadic false, :max-fixed-arity 3}), :line 309, :end-line 310, :max-fixed-arity 3, :fn-var true, :arglists (quote ([coll f] [coll f start])), :test true}, -count {:protocol-inline nil, :protocol cljs.core/ICounted, :name cljs.core/-count, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 247, :ret-tag number, :end-line 248, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([coll])), :test true}, keep {:protocol-inline nil, :name cljs.core/keep, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([f] [f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 3372, :end-line 3372, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f] [f coll])), :doc "Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a transducer when no collection is provided.", :test true}, char {:protocol-inline nil, :name cljs.core/char, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 1874, :end-line 1874, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to char", :test true}, mapcat {:protocol-inline nil, :added "1.0", :name cljs.core/mapcat, :variadic true, :file "out/cljs/core.cljs", :end-column 14, :static true, :method-params ([f] [f colls]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag any, :variadic true, :max-fixed-arity 1}), :line 3851, :end-line 3851, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f] [f & colls])), :doc "Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection. Returns\n  a transducer when no collections are provided", :test true}, unchecked-long {:protocol-inline nil, :name cljs.core/unchecked-long, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 1984, :end-line 1984, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to long by stripping decimal places. Identical to `int'.", :test true}, m3-seed {:file "out/cljs/core.cljs", :line 453, :column 1, :end-line 453, :end-column 14, :test true, :name cljs.core/m3-seed}, some? {:protocol-inline nil, :name cljs.core/some?, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 100, :ret-tag boolean, :end-line 100, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is not nil, false otherwise.", :test true}, unchecked-negate {:protocol-inline nil, :name cljs.core/unchecked-negate, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 1939, :end-line 1939, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, reverse {:protocol-inline nil, :name cljs.core/reverse, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil seq any}, :variadic false, :max-fixed-arity 1}), :line 2322, :end-line 2322, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a seq of the items in coll in reverse order. Not lazy.", :test true}, range {:protocol-inline nil, :name cljs.core/range, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([] [end] [start end] [start end step]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/Range, :variadic false, :max-fixed-arity 0} {:tag cljs.core/Range, :variadic false, :max-fixed-arity 1} {:tag cljs.core/Range, :variadic false, :max-fixed-arity 2} {:tag cljs.core/Range, :variadic false, :max-fixed-arity 3}), :line 7777, :end-line 7777, :max-fixed-arity 3, :fn-var true, :arglists (quote ([] [end] [start end] [start end step])), :doc "Returns a lazy seq of nums from start (inclusive) to end\n   (exclusive), by step, where start defaults to 0, step to 1,\n   and end to infinity.", :test true}, bit-count {:protocol-inline nil, :name cljs.core/bit-count, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 2076, :end-line 2076, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v])), :doc "Counts the number of bits set in n", :test true}, create-node {:protocol-inline nil, :private true, :name cljs.core/create-node, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any cljs.core/HashCollisionNode}, :variadic false, :max-fixed-arity 6} {:tag #{any cljs.core/HashCollisionNode}, :variadic false, :max-fixed-arity 7}), :line 5968, :end-line 5968, :max-fixed-arity 7, :fn-var true, :arglists (quote ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2])), :test true}, sort {:protocol-inline nil, :name cljs.core/sort, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([coll] [comp coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{seq cljs.core/IList}, :variadic false, :max-fixed-arity 1} {:tag #{seq cljs.core/IList}, :variadic false, :max-fixed-arity 2}), :line 1644, :end-line 1644, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll] [comp coll])), :doc "Returns a sorted sequence of the items in coll. Comp can be\n   boolean-valued comparison function, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :test true}, ->MetaFn {:protocol-inline nil, :protocols #{cljs.core/IFn cljs.core/IMeta cljs.core/Fn cljs.core/IWithMeta}, :name cljs.core/->MetaFn, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([afn meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/MetaFn, :variadic false, :max-fixed-arity 2}), :line 1333, :end-line 1333, :max-fixed-arity 2, :fn-var true, :arglists (quote ([afn meta])), :skip-protocol-flag #{cljs.core/IFn cljs.core/IMeta cljs.core/IWithMeta}, :test true}, unchecked-inc-int {:protocol-inline nil, :name cljs.core/unchecked-inc-int, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 1922, :end-line 1922, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, -compare {:protocol-inline nil, :protocol cljs.core/IComparable, :name cljs.core/-compare, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 382, :ret-tag number, :end-line 383, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x y])), :test true}, map-indexed {:protocol-inline nil, :name cljs.core/map-indexed, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 3353, :end-line 3353, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f coll])), :doc "Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item.", :test true}, array-list {:protocol-inline nil, :name cljs.core/array-list, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/ArrayList, :variadic false, :max-fixed-arity 0}), :line 7587, :end-line 7587, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :test true}, rand-nth {:protocol-inline nil, :name cljs.core/rand-nth, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 8614, :end-line 8614, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Return a random element of the (sequential) collection. Will have\n  the same performance characteristics as nth for the given\n  collection.", :test true}, comp {:protocol-inline nil, :name cljs.core/comp, :variadic true, :file "out/cljs/core.cljs", :end-column 12, :method-params ([] [f] [f g] [f g h] [f1 f2 f3 fs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 0} {:variadic false, :max-fixed-arity 1} {:tag function, :variadic false, :max-fixed-arity 2} {:tag function, :variadic false, :max-fixed-arity 3} {:tag function, :variadic true, :max-fixed-arity 3}), :line 3272, :end-line 3272, :max-fixed-arity 3, :fn-var true, :arglists (quote ([] [f] [f g] [f g h] [f1 f2 f3 & fs])), :doc "Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc.", :test true}, array-chunk {:protocol-inline nil, :name cljs.core/array-chunk, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([arr] [arr off] [arr off end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/ArrayChunk, :variadic false, :max-fixed-arity 1} {:tag cljs.core/ArrayChunk, :variadic false, :max-fixed-arity 2} {:tag cljs.core/ArrayChunk, :variadic false, :max-fixed-arity 3}), :line 2589, :end-line 2589, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr] [arr off] [arr off end])), :test true}, bit-shift-right-zero-fill {:protocol-inline nil, :name cljs.core/bit-shift-right-zero-fill, :variadic false, :file "out/cljs/core.cljs", :end-column 33, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2068, :end-line 2068, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "DEPRECATED: Bitwise shift right with zero fill", :test true}, -as-transient {:protocol-inline nil, :protocol cljs.core/IEditableCollection, :name cljs.core/-as-transient, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 362, :ret-tag clj, :end-line 363, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([coll])), :test true}, dorun {:protocol-inline nil, :name cljs.core/dorun, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([coll] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 1} {:tag clj-nil, :variadic false, :max-fixed-arity 2}), :line 7910, :end-line 7910, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll] [n coll])), :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. dorun can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, does not retain the head and returns nil.", :test true}, pr-sequential-writer {:protocol-inline nil, :name cljs.core/pr-sequential-writer, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([writer print-one begin sep end opts coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 7}), :line 7987, :end-line 7987, :max-fixed-arity 7, :fn-var true, :arglists (quote ([writer print-one begin sep end opts coll])), :test true}, accumulating-seq-count {:protocol-inline nil, :private true, :name cljs.core/accumulating-seq-count, :variadic false, :file "out/cljs/core.cljs", :end-column 31, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 1138, :end-line 1138, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, IIndexed {:protocol-symbol true, :name cljs.core/IIndexed, :file "out/cljs/core.cljs", :end-column 23, :column 1, :line 259, :protocol-info {:methods {-nth [[coll n] [coll n not-found]]}}, :info nil, :end-line 259, :impls #{cljs.core/TransientVector cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/Subvec cljs.core/PersistentVector cljs.core/ArrayChunk cljs.core/Range cljs.core/RedNode}, :test true}, disj {:protocol-inline nil, :name cljs.core/disj, :variadic true, :file "out/cljs/core.cljs", :end-column 12, :method-params ([coll] [coll k] [coll k ks]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1} {:tag #{clj clj-nil}, :variadic false, :max-fixed-arity 2} {:tag #{clj clj-nil}, :variadic true, :max-fixed-arity 2}), :line 1417, :end-line 1417, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll] [coll k] [coll k & ks])), :doc "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s).", :test true}, IPrintWithWriter {:protocol-symbol true, :name cljs.core/IPrintWithWriter, :file "out/cljs/core.cljs", :end-column 31, :column 1, :line 346, :protocol-info {:methods {-pr-writer [[o writer opts]]}}, :info nil, :end-line 346, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/Eduction cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/Volatile cljs.core/Keyword cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/Var cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/ES6IteratorSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/Atom cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/LazyTransformer cljs.core/UUID cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :test true}, ->UUID {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter}, :name cljs.core/->UUID, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([uuid]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/UUID, :variadic false, :max-fixed-arity 1}), :line 9027, :end-line 9027, :max-fixed-arity 1, :fn-var true, :arglists (quote ([uuid])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter}, :test true}, IVector {:protocol-symbol true, :name cljs.core/IVector, :file "out/cljs/core.cljs", :end-column 22, :column 1, :line 294, :protocol-info {:methods {-assoc-n [[coll n val]]}}, :info nil, :end-line 294, :impls #{cljs.core/BlackNode cljs.core/Subvec cljs.core/PersistentVector cljs.core/RedNode}, :test true}, IIterable {:protocol-symbol true, :name cljs.core/IIterable, :file "out/cljs/core.cljs", :end-column 24, :column 1, :line 410, :protocol-info {:methods {-iterator [[coll]]}}, :info nil, :end-line 410, :impls #{cljs.core/PersistentArrayMap cljs.core/IndexedSeq cljs.core/PersistentVector cljs.core/Range}, :test true}, *2 {:file "out/cljs/core.cljs", :line 63, :column 1, :end-line 65, :end-column 6, :doc "bound in a repl thread to the second most recent value printed", :test true, :name cljs.core/*2}, Eduction {:num-fields 2, :protocols #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/ISequential cljs.core/IReduce}, :name cljs.core/Eduction, :file "out/cljs/core.cljs", :end-column 19, :type true, :column 10, :line 8474, :record false, :end-line 8474, :skip-protocol-flag #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/ISequential cljs.core/IReduce}}, pv-clone-node {:protocol-inline nil, :private true, :name cljs.core/pv-clone-node, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/VectorNode, :variadic false, :max-fixed-arity 1}), :line 4068, :end-line 4068, :max-fixed-arity 1, :fn-var true, :arglists (quote ([node])), :test true}, cons {:protocol-inline nil, :name cljs.core/cons, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([x coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/Cons, :variadic false, :max-fixed-arity 2}), :line 2393, :end-line 2393, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x coll])), :doc "Returns a new seq where x is the first element and seq is the rest.", :test true}, PersistentTreeSet {:num-fields 3, :protocols #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :name cljs.core/PersistentTreeSet, :file "out/cljs/core.cljs", :end-column 28, :type true, :column 10, :line 7375, :record false, :end-line 7375, :skip-protocol-flag #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}}, floats {:protocol-inline nil, :name cljs.core/floats, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1994, :end-line 1994, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, TransientVector {:num-fields 4, :protocols #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/TransientVector, :file "out/cljs/core.cljs", :end-column 26, :type true, :column 10, :line 4648, :record false, :declared true, :end-line 4648, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}, :test true}, pos? {:protocol-inline nil, :name cljs.core/pos?, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 2096, :ret-tag boolean, :end-line 2096, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :doc "Returns true if num is greater than zero, else false", :test true}, fnil {:protocol-inline nil, :name cljs.core/fnil, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([f x] [f x y] [f x y z]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 2} {:tag function, :variadic false, :max-fixed-arity 3} {:tag function, :variadic false, :max-fixed-arity 4}), :line 3330, :end-line 3330, :max-fixed-arity 4, :fn-var true, :arglists (quote ([f x] [f x y] [f x y z])), :doc "Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched.", :test true}, merge-with {:protocol-inline nil, :name cljs.core/merge-with, :variadic true, :file "out/cljs/core.cljs", :end-column 18, :method-params ([f maps]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any clj-nil}, :variadic true, :max-fixed-arity 1}), :line 7209, :end-line 7209, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f & maps])), :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping(s)\n  from the latter (left-to-right) will be combined with the mapping in\n  the result by calling (f val-in-result val-in-latter).", :test true}, nthrest {:protocol-inline nil, :name cljs.core/nthrest, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([coll n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 1249, :end-line 1249, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll n])), :doc "Returns the nth rest of coll, coll when n is 0.", :test true}, sequential? {:protocol-inline nil, :name cljs.core/sequential?, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1455, :ret-tag boolean, :end-line 1455, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll satisfies ISequential", :test true}, tree-map-replace {:protocol-inline nil, :private true, :name cljs.core/tree-map-replace, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([comp tree k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 4}), :line 6859, :end-line 6859, :max-fixed-arity 4, :fn-var true, :arglists (quote ([comp tree k v])), :test true}, m3-mix-H1 {:protocol-inline nil, :name cljs.core/m3-mix-H1, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([h1 k1]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 460, :ret-tag number, :end-line 460, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([h1 k1])), :test true}, ->TransientArrayMap {:protocol-inline nil, :protocols #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/->TransientArrayMap, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([editable? len arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/TransientArrayMap, :variadic false, :max-fixed-arity 3}), :line 5411, :end-line 5411, :max-fixed-arity 3, :fn-var true, :arglists (quote ([editable? len arr])), :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :test true}, prim-seq {:protocol-inline nil, :name cljs.core/prim-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([prim] [prim i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/IndexedSeq clj-nil}, :variadic false, :max-fixed-arity 1} {:tag #{cljs.core/IndexedSeq clj-nil}, :variadic false, :max-fixed-arity 2}), :line 1010, :end-line 1010, :max-fixed-arity 2, :fn-var true, :arglists (quote ([prim] [prim i])), :test true}, *print-level* {:file "out/cljs/core.cljs", :line 38, :column 1, :end-line 38, :end-column 30, :dynamic true, :test true, :name cljs.core/*print-level*}, shuffle {:protocol-inline nil, :name cljs.core/shuffle, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 1685, :end-line 1685, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Return a random permutation of coll", :test true}, ChunkedSeq {:num-fields 6, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/ChunkedSeq, :file "out/cljs/core.cljs", :end-column 21, :type true, :column 10, :line 4391, :record false, :declared true, :end-line 4391, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, hash-keyword {:protocol-inline nil, :name cljs.core/hash-keyword, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 2404, :end-line 2404, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k])), :test true}, find {:protocol-inline nil, :name cljs.core/find, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([coll k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/IVector clj-nil}, :variadic false, :max-fixed-arity 2}), :line 1566, :end-line 1566, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll k])), :doc "Returns the map entry for key, or nil if key not present.", :test true}, alength {:protocol-inline nil, :name cljs.core/alength, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([array]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 195, :ret-tag number, :end-line 195, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([array])), :doc "Returns the length of the array. Works on arrays of all types.", :test true}, bit-xor {:protocol-inline nil, :name cljs.core/bit-xor, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2020, :end-line 2020, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x y])), :doc "Bitwise exclusive or", :test true}, ->IndexedSeq {:protocol-inline nil, :protocols #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IReduce}, :name cljs.core/->IndexedSeq, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([arr i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/IndexedSeq, :variadic false, :max-fixed-arity 2}), :line 940, :end-line 940, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr i])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ICloneable cljs.core/ISequential cljs.core/IReduce}, :test true}, ObjMap {:num-fields 5, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/ObjMap, :file "out/cljs/core.cljs", :end-column 17, :type true, :column 10, :line 4948, :record false, :end-line 4948, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, unsigned-bit-shift-right {:protocol-inline nil, :name cljs.core/unsigned-bit-shift-right, :variadic false, :file "out/cljs/core.cljs", :end-column 32, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2072, :end-line 2072, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Bitwise shift right with zero fill", :test true}, ES6SetEntriesIterator {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/ES6SetEntriesIterator, :file "out/cljs/core.cljs", :end-column 32, :type true, :column 10, :line 5072, :record false, :end-line 5072, :skip-protocol-flag nil}, neg? {:protocol-inline nil, :name cljs.core/neg?, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 2103, :ret-tag boolean, :end-line 2103, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if num is less than zero, else false", :test true}, Cons {:num-fields 4, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/Cons, :file "out/cljs/core.cljs", :end-column 15, :type true, :column 10, :line 2344, :record false, :end-line 2344, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -remove-method {:protocol-inline nil, :protocol cljs.core/IMultiFn, :name cljs.core/-remove-method, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([mf dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 8799, :end-line 8802, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mf dispatch-val])), :test true}, ->StringIter {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->StringIter, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([s i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/StringIter, :variadic false, :max-fixed-arity 2}), :line 2994, :end-line 2994, :max-fixed-arity 2, :fn-var true, :arglists (quote ([s i])), :skip-protocol-flag nil, :test true}, js-invoke {:protocol-inline nil, :name cljs.core/js-invoke, :variadic true, :file "out/cljs/core.cljs", :end-column 17, :method-params ([obj s args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic true, :max-fixed-arity 2}), :line 208, :end-line 208, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj s & args])), :doc "Invoke JavaScript object method via string. Needed when the\n  string is not a valid unquoted property name.", :test true}, ->List {:protocol-inline nil, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->List, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([meta first rest count __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/List, :variadic false, :max-fixed-arity 5}), :line 2199, :end-line 2199, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta first rest count __hash])), :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, m3-mix-K1 {:protocol-inline nil, :name cljs.core/m3-mix-K1, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([k1]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 457, :ret-tag number, :end-line 457, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([k1])), :test true}, unchecked-float {:protocol-inline nil, :name cljs.core/unchecked-float, :variadic false, :file "out/cljs/core.cljs", :end-column 31, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1889, :ret-tag number, :end-line 1889, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x])), :test true}, undefined? {:protocol-inline nil, :name cljs.core/undefined?, :variadic false, :file "out/cljs/core.cljs", :end-column 27, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1526, :ret-tag boolean, :end-line 1526, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :test true}, IMeta {:protocol-symbol true, :name cljs.core/IMeta, :file "out/cljs/core.cljs", :end-column 20, :column 1, :line 303, :protocol-info {:methods {-meta [[o]]}}, :info nil, :end-line 303, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/t11986 cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/Var cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/t11983 cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet function cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/Atom cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/MetaFn cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :test true}, reduced? {:protocol-inline nil, :name cljs.core/reduced?, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([r]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 836, :ret-tag boolean, :end-line 836, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([r])), :doc "Returns true if x is the result of a call to reduced", :test true}, apply-to {:protocol-inline nil, :name cljs.core/apply-to, :variadic false, :file "out/cljs/core.cljs", :method-params ([f argc args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 2908, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f argc args])), :test true}, disj! {:protocol-inline nil, :name cljs.core/disj!, :variadic true, :file "out/cljs/core.cljs", :end-column 13, :method-params ([tcoll val] [tcoll val vals]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2} {:tag clj, :variadic true, :max-fixed-arity 2}), :line 2893, :end-line 2893, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tcoll val] [tcoll val & vals])), :doc "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n  does not contain key(s).", :test true}, -lookup {:protocol-inline nil, :protocol cljs.core/ILookup, :name cljs.core/-lookup, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([o k] [o k not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:tag any, :variadic false, :max-fixed-arity 3}), :line 271, :end-line 272, :max-fixed-arity 3, :fn-var true, :arglists (quote ([o k] [o k not-found])), :test true}, ICloneable {:protocol-symbol true, :name cljs.core/ICloneable, :file "out/cljs/core.cljs", :end-column 25, :column 1, :line 244, :protocol-info {:methods {-clone [[value]]}}, :info nil, :end-line 244, :impls #{cljs.core/PersistentHashMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/EmptyList cljs.core/Subvec cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet cljs.core/Range}, :test true}, IEncodeClojure {:protocol-symbol true, :name cljs.core/IEncodeClojure, :file "out/cljs/core.cljs", :end-column 29, :column 1, :line 8540, :protocol-info {:methods {-js->clj [[x options]]}}, :info nil, :end-line 8540, :impls #{}, :test true}, booleans {:protocol-inline nil, :name cljs.core/booleans, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1989, :end-line 1989, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, array-map-index-of-symbol? {:protocol-inline nil, :private true, :name cljs.core/array-map-index-of-symbol?, :variadic false, :file "out/cljs/core.cljs", :end-column 35, :method-params ([arr m k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 3}), :line 5105, :end-line 5105, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr m k])), :test true}, ->ArrayList {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->ArrayList, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ArrayList, :variadic false, :max-fixed-arity 1}), :line 7579, :end-line 7579, :max-fixed-arity 1, :fn-var true, :arglists (quote ([arr])), :skip-protocol-flag nil, :test true}, RSeq {:num-fields 3, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/RSeq, :file "out/cljs/core.cljs", :end-column 15, :type true, :column 10, :line 1025, :record false, :declared true, :end-line 1025, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, mask {:protocol-inline nil, :private true, :name cljs.core/mask, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([hash shift]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 5500, :end-line 5500, :max-fixed-arity 2, :fn-var true, :arglists (quote ([hash shift])), :test true}, int-array {:protocol-inline nil, :name cljs.core/int-array, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([size-or-seq] [size init-val-or-seq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1} {:tag array, :variadic false, :max-fixed-arity 2}), :line 2706, :end-line 2706, :max-fixed-arity 2, :fn-var true, :arglists (quote ([size-or-seq] [size init-val-or-seq])), :test true}, find-and-cache-best-method {:protocol-inline nil, :private true, :name cljs.core/find-and-cache-best-method, :variadic false, :file "out/cljs/core.cljs", :end-column 35, :method-params ([name dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 7}), :line 8774, :end-line 8774, :max-fixed-arity 7, :fn-var true, :arglists (quote ([name dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy])), :test true}, set? {:protocol-inline nil, :name cljs.core/set?, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1444, :ret-tag boolean, :end-line 1444, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x satisfies ISet", :test true}, iterable? {:protocol-inline nil, :name cljs.core/iterable?, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 636, :end-line 636, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, cat {:protocol-inline nil, :added "1.7", :name cljs.core/cat, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([rf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1}), :line 8435, :end-line 8435, :max-fixed-arity 1, :fn-var true, :arglists (quote ([rf])), :doc "A transducer which concatenates the contents of each input, which must be a\n  collection, into the reduction.", :test true}, ->ES6EntriesIterator {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->ES6EntriesIterator, :variadic false, :file "out/cljs/core.cljs", :end-column 29, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ES6EntriesIterator, :variadic false, :max-fixed-arity 1}), :line 5059, :end-line 5059, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :skip-protocol-flag nil, :test true}, divide {:file "out/cljs/core.cljs", :line 1797, :column 1, :end-line 1797, :end-column 17, :declared true, :test true, :name cljs.core/divide}, -pr-writer {:protocol-inline nil, :protocol cljs.core/IPrintWithWriter, :name cljs.core/-pr-writer, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([o writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 346, :end-line 352, :max-fixed-arity 3, :fn-var true, :arglists (quote ([o writer opts])), :test true}, flush {:protocol-inline nil, :name cljs.core/flush, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 0}), :line 8014, :end-line 8014, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :test true}, set-from-indexed-seq {:protocol-inline nil, :name cljs.core/set-from-indexed-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([iseq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 7468, :end-line 7468, :max-fixed-arity 1, :fn-var true, :arglists (quote ([iseq])), :test true}, take-while {:protocol-inline nil, :name cljs.core/take-while, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([pred] [pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 7621, :end-line 7621, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of successive items from coll while\n  (pred item) returns true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :test true}, vary-meta {:protocol-inline nil, :name cljs.core/vary-meta, :variadic true, :file "out/cljs/core.cljs", :end-column 17, :method-params ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d] [obj f a b c d args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{clj cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 2} {:tag #{clj cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 3} {:tag #{clj cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 4} {:tag #{clj cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 5} {:tag #{clj cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 6} {:tag #{clj cljs.core/MetaFn clj-nil}, :variadic true, :max-fixed-arity 6}), :line 2960, :end-line 2960, :max-fixed-arity 6, :fn-var true, :arglists (quote ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d] [obj f a b c d & args])), :doc "Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata.", :test true}, INext {:protocol-symbol true, :name cljs.core/INext, :file "out/cljs/core.cljs", :end-column 20, :column 1, :line 268, :protocol-info {:methods {-next [[coll]]}}, :info nil, :end-line 268, :impls #{cljs.core/Cons cljs.core/IndexedSeq cljs.core/EmptyList cljs.core/LazySeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/List cljs.core/RSeq cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range}, :test true}, is_proto_ {:protocol-inline nil, :name cljs.core/is_proto_, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 123, :end-line 123, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, START {:file "out/cljs/core.cljs", :line 3019, :column 1, :end-line 3019, :end-column 12, :test true, :name cljs.core/START}, ICounted {:protocol-symbol true, :name cljs.core/ICounted, :file "out/cljs/core.cljs", :end-column 23, :column 1, :line 247, :protocol-info {:methods {-count [[coll]]}}, :info nil, :end-line 247, :impls #{nil cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/TransientVector cljs.core/PersistentArrayMap cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/Subvec cljs.core/TransientHashMap cljs.core/ChunkBuffer cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/TransientArrayMap cljs.core/RSeq cljs.core/TransientHashSet cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/ArrayChunk cljs.core/PersistentTreeSet cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :test true}, IMapEntry {:protocol-symbol true, :name cljs.core/IMapEntry, :file "out/cljs/core.cljs", :end-column 24, :column 1, :line 283, :protocol-info {:methods {-key [[coll]], -val [[coll]]}}, :info nil, :end-line 283, :impls #{cljs.core/BlackNode cljs.core/PersistentVector cljs.core/RedNode}, :test true}, <= {:protocol-inline nil, :name cljs.core/<=, :variadic true, :file "out/cljs/core.cljs", :end-column 19, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1} {:tag boolean, :variadic false, :max-fixed-arity 2} {:tag boolean, :variadic true, :max-fixed-arity 2}), :line 1818, :ret-tag boolean, :end-line 1818, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false.", :test true}, conj! {:protocol-inline nil, :name cljs.core/conj!, :variadic true, :file "out/cljs/core.cljs", :end-column 13, :method-params ([] [coll] [tcoll val] [tcoll val vals]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 0} {:variadic false, :max-fixed-arity 1} {:tag clj, :variadic false, :max-fixed-arity 2} {:tag clj, :variadic true, :max-fixed-arity 2}), :line 2852, :end-line 2852, :max-fixed-arity 2, :fn-var true, :arglists (quote ([] [coll] [tcoll val] [tcoll val & vals])), :doc "Adds x to the transient collection, and return coll. The 'addition'\n  may happen at different 'places' depending on the concrete type.", :test true}, -pop {:protocol-inline nil, :protocol cljs.core/IStack, :name cljs.core/-pop, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 290, :ret-tag clj, :end-line 292, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([coll])), :test true}, repeatedly {:protocol-inline nil, :name cljs.core/repeatedly, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([f] [n f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 3805, :end-line 3805, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f] [n f])), :doc "Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it", :test true}, zipmap {:protocol-inline nil, :name cljs.core/zipmap, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([keys vals]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2}), :line 7553, :end-line 7553, :max-fixed-arity 2, :fn-var true, :arglists (quote ([keys vals])), :doc "Returns a map with the keys mapped to the corresponding vals.", :test true}, IStack {:protocol-symbol true, :name cljs.core/IStack, :file "out/cljs/core.cljs", :end-column 21, :column 1, :line 290, :protocol-info {:methods {-peek [[coll]], -pop [[coll]]}}, :info nil, :end-line 290, :impls #{cljs.core/PersistentQueue cljs.core/BlackNode cljs.core/EmptyList cljs.core/Subvec cljs.core/PersistentVector cljs.core/List cljs.core/RedNode}, :test true}, -remove-watch {:protocol-inline nil, :protocol cljs.core/IWatchable, :name cljs.core/-remove-watch, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([this key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 357, :end-line 360, :max-fixed-arity 2, :fn-var true, :arglists (quote ([this key])), :test true}, IVolatile {:protocol-symbol true, :name cljs.core/IVolatile, :file "out/cljs/core.cljs", :end-column 24, :column 1, :line 407, :protocol-info {:methods {-vreset! [[o new-value]]}}, :info nil, :end-line 407, :impls #{cljs.core/Volatile}, :test true}, remove {:protocol-inline nil, :name cljs.core/remove, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([pred] [pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 3890, :end-line 3890, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns false. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :test true}, ->BitmapIndexedNode {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->BitmapIndexedNode, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([edit bitmap arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/BitmapIndexedNode, :variadic false, :max-fixed-arity 3}), :line 5553, :end-line 5553, :max-fixed-arity 3, :fn-var true, :arglists (quote ([edit bitmap arr])), :skip-protocol-flag nil, :test true}, * {:protocol-inline nil, :name cljs.core/*, :variadic true, :file "out/cljs/core.cljs", :end-column 17, :method-params ([] [x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 0} {:variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 1790, :ret-tag number, :end-line 1790, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the product of nums. (*) returns 1.", :test true}, re-pattern {:protocol-inline nil, :name cljs.core/re-pattern, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil js/RegExp}, :variadic false, :max-fixed-arity 1}), :line 7977, :end-line 7977, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Returns an instance of RegExp which has compiled the provided string.", :test true}, min {:protocol-inline nil, :name cljs.core/min, :variadic true, :file "out/cljs/core.cljs", :end-column 19, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1} {:variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 1865, :ret-tag number, :end-line 1865, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns the least of the nums.", :test true}, array-map-index-of-nil? {:protocol-inline nil, :private true, :name cljs.core/array-map-index-of-nil?, :variadic false, :file "out/cljs/core.cljs", :end-column 32, :method-params ([arr m k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 3}), :line 5086, :end-line 5086, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr m k])), :test true}, -persistent! {:protocol-inline nil, :protocol cljs.core/ITransientCollection, :name cljs.core/-persistent!, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([tcoll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 365, :ret-tag clj, :end-line 367, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([tcoll])), :test true}, -nth {:protocol-inline nil, :protocol cljs.core/IIndexed, :name cljs.core/-nth, :variadic false, :file "out/cljs/core.cljs", :end-column 9, :method-params ([coll n] [coll n not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:tag any, :variadic false, :max-fixed-arity 3}), :line 259, :end-line 260, :max-fixed-arity 3, :fn-var true, :arglists (quote ([coll n] [coll n not-found])), :test true}, pop! {:protocol-inline nil, :name cljs.core/pop!, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([tcoll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 2887, :end-line 2887, :max-fixed-arity 1, :fn-var true, :arglists (quote ([tcoll])), :doc "Removes the last item from a transient vector. If\n  the collection is empty, throws an exception. Returns coll", :test true}, chunk-append {:protocol-inline nil, :name cljs.core/chunk-append, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([b x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 2666, :end-line 2666, :max-fixed-arity 2, :fn-var true, :arglists (quote ([b x])), :test true}, prn-str {:protocol-inline nil, :name cljs.core/prn-str, :variadic true, :file "out/cljs/core.cljs", :end-column 15, :method-params ([objs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil string}, :variadic true, :max-fixed-arity 0}), :line 8153, :end-line 8153, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& objs])), :doc "Same as pr-str followed by (newline)", :test true}, IReversible {:protocol-symbol true, :name cljs.core/IReversible, :file "out/cljs/core.cljs", :end-column 26, :column 1, :line 333, :protocol-info {:methods {-rseq [[coll]]}}, :info nil, :end-line 333, :impls #{cljs.core/IndexedSeq cljs.core/Subvec cljs.core/PersistentVector cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet}, :test true}, reversible? {:protocol-inline nil, :name cljs.core/reversible?, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 2316, :ret-tag boolean, :end-line 2316, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([coll])), :test true}, -realized? {:protocol-inline nil, :protocol cljs.core/IPending, :name cljs.core/-realized?, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([d]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 354, :ret-tag boolean, :end-line 355, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([d])), :test true}, -add-watch {:protocol-inline nil, :protocol cljs.core/IWatchable, :name cljs.core/-add-watch, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([this key f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 357, :end-line 359, :max-fixed-arity 3, :fn-var true, :arglists (quote ([this key f])), :test true}, -deref-with-timeout {:protocol-inline nil, :protocol cljs.core/IDerefWithTimeout, :name cljs.core/-deref-with-timeout, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([o msec timeout-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 300, :end-line 301, :max-fixed-arity 3, :fn-var true, :arglists (quote ([o msec timeout-val])), :test true}, conj {:protocol-inline nil, :name cljs.core/conj, :variadic true, :file "out/cljs/core.cljs", :end-column 12, :method-params ([] [coll] [coll x] [coll x xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/IVector, :variadic false, :max-fixed-arity 0} {:variadic false, :max-fixed-arity 1} {:tag clj, :variadic false, :max-fixed-arity 2} {:tag clj, :variadic true, :max-fixed-arity 2}), :line 1117, :end-line 1117, :max-fixed-arity 2, :fn-var true, :arglists (quote ([] [coll] [coll x] [coll x & xs])), :doc "conj[oin]. Returns a new collection with the xs\n  'added'. (conj nil item) returns (item).  The 'addition' may\n  happen at different 'places' depending on the concrete type.", :test true}, -sorted-seq {:protocol-inline nil, :protocol cljs.core/ISorted, :name cljs.core/-sorted-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([coll ascending?]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 336, :ret-tag clj, :end-line 337, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([coll ascending?])), :test true}, flatten1 {:protocol-inline nil, :private true, :name cljs.core/flatten1, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([colls]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 1}), :line 3837, :end-line 3837, :max-fixed-arity 1, :fn-var true, :arglists (quote ([colls])), :doc "Take a collection of collections, and return a lazy seq\n  of items from the inner collection", :test true}, transduce {:protocol-inline nil, :name cljs.core/transduce, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([xform f coll] [xform f init coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3} {:tag any, :variadic false, :max-fixed-arity 4}), :line 1757, :end-line 1757, :max-fixed-arity 4, :fn-var true, :arglists (quote ([xform f coll] [xform f init coll])), :doc "reduce with a transformation of f (xf). If init is not\n  supplied, (f) will be called to produce it. f should be a reducing\n  step function that accepts both 1 and 2 arguments, if it accepts\n  only 2 you can add the arity-1 with 'completing'. Returns the result\n  of applying (the transformed) xf to init and the first item in coll,\n  then applying xf to that result and the 2nd item, etc. If coll\n  contains no items, returns init and f is not called. Note that\n  certain transforms may inject or skip items.", :test true}, fixture1 {:file "out/cljs/core.cljs", :line 8395, :column 1, :end-line 8395, :end-column 15, :test true, :name cljs.core/fixture1}, -swap! {:protocol-inline nil, :protocol cljs.core/ISwap, :name cljs.core/-swap!, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([o f] [o f a] [o f a b] [o f a b xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:tag any, :variadic false, :max-fixed-arity 3} {:tag any, :variadic false, :max-fixed-arity 4} {:tag any, :variadic false, :max-fixed-arity 5}), :line 404, :end-line 405, :max-fixed-arity 5, :fn-var true, :arglists (quote ([o f] [o f a] [o f a b] [o f a b xs])), :test true}, *print-length* {:file "out/cljs/core.cljs", :line 37, :column 1, :end-line 37, :end-column 31, :dynamic true, :test true, :name cljs.core/*print-length*}, js-delete {:protocol-inline nil, :name cljs.core/js-delete, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([obj key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 1495, :end-line 1495, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj key])), :test true}, truth_ {:protocol-inline nil, :name cljs.core/truth_, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 71, :end-line 71, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Internal - do not use!", :test true}, ->MultiFn {:protocol-inline nil, :protocols #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}, :name cljs.core/->MultiFn, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/MultiFn, :variadic false, :max-fixed-arity 8}), :line 8811, :end-line 8811, :max-fixed-arity 8, :fn-var true, :arglists (quote ([name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy])), :skip-protocol-flag #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}, :test true}, key->js {:protocol-inline nil, :name cljs.core/key->js, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any string}, :variadic false, :max-fixed-arity 1}), :line 8509, :end-line 8509, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k])), :test true}, ->MultiStepper {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->MultiStepper, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([xform iters nexts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/MultiStepper, :variadic false, :max-fixed-arity 3}), :line 3085, :end-line 3085, :max-fixed-arity 3, :fn-var true, :arglists (quote ([xform iters nexts])), :skip-protocol-flag nil, :test true}, IEncodeJS {:protocol-symbol true, :name cljs.core/IEncodeJS, :file "out/cljs/core.cljs", :end-column 24, :column 1, :line 8502, :protocol-info {:methods {-clj->js [[x]], -key->js [[x]]}}, :info nil, :end-line 8502, :impls #{}, :test true}, new-path {:protocol-inline nil, :private true, :name cljs.core/new-path, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([edit level node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 3}), :line 4077, :end-line 4077, :max-fixed-arity 3, :fn-var true, :arglists (quote ([edit level node])), :test true}, compare-and-set! {:protocol-inline nil, :name cljs.core/compare-and-set!, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([a oldval newval]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 3}), :line 3491, :end-line 3491, :max-fixed-arity 3, :fn-var true, :arglists (quote ([a oldval newval])), :doc "Atomically sets the value of atom to newval if and only if the\n  current value of the atom is equal to oldval. Returns true if\n  set happened, else false.", :test true}, array-seq {:protocol-inline nil, :name cljs.core/array-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([array] [array i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/IndexedSeq clj-nil}, :variadic false, :max-fixed-arity 1} {:tag #{cljs.core/IndexedSeq clj-nil}, :variadic false, :max-fixed-arity 2}), :line 1017, :end-line 1017, :max-fixed-arity 2, :fn-var true, :arglists (quote ([array] [array i])), :test true}, array-copy-downward {:protocol-inline nil, :private true, :name cljs.core/array-copy-downward, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([from i to j len]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 5}), :line 1506, :end-line 1506, :max-fixed-arity 5, :fn-var true, :arglists (quote ([from i to j len])), :test true}, pack-array-node {:protocol-inline nil, :private true, :name cljs.core/pack-array-node, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([array-node edit idx]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/BitmapIndexedNode, :variadic false, :max-fixed-arity 3}), :line 5751, :end-line 5751, :max-fixed-arity 3, :fn-var true, :arglists (quote ([array-node edit idx])), :test true}, interleave {:protocol-inline nil, :name cljs.core/interleave, :variadic true, :file "out/cljs/core.cljs", :end-column 18, :method-params ([c1 c2] [c1 c2 colls]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2} {:tag cljs.core/LazySeq, :variadic true, :max-fixed-arity 2}), :line 3817, :end-line 3817, :max-fixed-arity 2, :fn-var true, :arglists (quote ([c1 c2] [c1 c2 & colls])), :doc "Returns a lazy seq of the first item in each coll, then the second etc.", :test true}, print-map {:protocol-inline nil, :name cljs.core/print-map, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([m print-one writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 4}), :line 8197, :end-line 8197, :max-fixed-arity 4, :fn-var true, :arglists (quote ([m print-one writer opts])), :test true}, map? {:protocol-inline nil, :name cljs.core/map?, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1467, :ret-tag boolean, :end-line 1467, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies IMap", :test true}, m3-C1 {:file "out/cljs/core.cljs", :line 454, :column 1, :end-line 454, :end-column 12, :test true, :name cljs.core/m3-C1}, get {:protocol-inline nil, :name cljs.core/get, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([o k] [o k not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any clj-nil}, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 1257, :end-line 1257, :max-fixed-arity 3, :fn-var true, :arglists (quote ([o k] [o k not-found])), :doc "Returns the value mapped to key, not-found or nil if key not present.", :test true}, identity {:protocol-inline nil, :name cljs.core/identity, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1747, :end-line 1747, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, into {:protocol-inline nil, :name cljs.core/into, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([to from] [to xform from]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj any cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 2} {:tag #{clj any cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 3}), :line 3921, :end-line 3921, :max-fixed-arity 3, :fn-var true, :arglists (quote ([to from] [to xform from])), :doc "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined. A transducer may be supplied.", :test true}, long {:protocol-inline nil, :name cljs.core/long, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 1979, :end-line 1979, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to long by stripping decimal places. Identical to `int'.", :test true}, double {:protocol-inline nil, :name cljs.core/double, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1884, :ret-tag number, :end-line 1884, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x])), :test true}, volatile? {:protocol-inline nil, :name cljs.core/volatile?, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 3528, :end-line 3528, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is a volatile.", :test true}, ChunkBuffer {:num-fields 2, :protocols #{cljs.core/Object cljs.core/ICounted}, :name cljs.core/ChunkBuffer, :file "out/cljs/core.cljs", :end-column 22, :type true, :column 10, :line 2548, :record false, :end-line 2548, :skip-protocol-flag #{cljs.core/ICounted}}, -key {:protocol-inline nil, :protocol cljs.core/IMapEntry, :name cljs.core/-key, :variadic false, :file "out/cljs/core.cljs", :end-column 9, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 283, :end-line 284, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, nfirst {:protocol-inline nil, :name cljs.core/nfirst, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag seq, :variadic false, :max-fixed-arity 1}), :line 1090, :end-line 1090, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (next (first x))", :test true}, StringBufferWriter {:num-fields 1, :protocols #{cljs.core/IWriter}, :name cljs.core/StringBufferWriter, :file "out/cljs/core.cljs", :end-column 29, :type true, :column 10, :line 415, :record false, :end-line 415, :skip-protocol-flag #{cljs.core/IWriter}}, meta {:protocol-inline nil, :name cljs.core/meta, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{clj-or-nil clj-nil}, :variadic false, :max-fixed-arity 1}), :line 1395, :end-line 1395, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o])), :doc "Returns the metadata of obj, returns nil if there is no metadata.", :test true}, tv-editable-tail {:protocol-inline nil, :private true, :name cljs.core/tv-editable-tail, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([tl]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1}), :line 4601, :end-line 4601, :max-fixed-arity 1, :fn-var true, :arglists (quote ([tl])), :test true}, -kv-reduce {:protocol-inline nil, :protocol cljs.core/IKVReduce, :name cljs.core/-kv-reduce, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([coll f init]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 312, :end-line 313, :max-fixed-arity 3, :fn-var true, :arglists (quote ([coll f init])), :test true}, IHash {:protocol-symbol true, :name cljs.core/IHash, :file "out/cljs/core.cljs", :end-column 20, :column 1, :line 318, :protocol-info {:methods {-hash [[o]]}}, :info nil, :end-line 318, :impls #{cljs.core/PersistentHashMap cljs.core/MultiFn cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/Keyword cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq default cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/Atom cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/LazyTransformer cljs.core/UUID cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :test true}, t11983 {:num-fields 2, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/t11983, :file "out/cljs/core.cljs", :type true, :anonymous true, :column 3, :line 2988, :record false, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, bit-and-not {:protocol-inline nil, :name cljs.core/bit-and-not, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2032, :end-line 2032, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x y])), :doc "Bitwise and", :test true}, -comparator {:protocol-inline nil, :protocol cljs.core/ISorted, :name cljs.core/-comparator, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 336, :end-line 340, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, unchecked-add-int {:protocol-inline nil, :name cljs.core/unchecked-add-int, :variadic true, :file "out/cljs/core.cljs", :end-column 33, :method-params ([] [x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 0} {:variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 1899, :ret-tag number, :end-line 1899, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the sum of nums. (+) returns 0.", :test true}, hash-ordered-coll {:protocol-inline nil, :name cljs.core/hash-ordered-coll, :variadic false, :file "out/cljs/core.cljs", :end-column 33, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 764, :ret-tag number, :end-line 764, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([coll])), :doc "Returns the hash code, consistent with =, for an external ordered\n   collection implementing Iterable.\n   See http://clojure.org/data_structures#hash for full algorithms.", :test true}, extend-object! {:protocol-inline nil, :private true, :name cljs.core/extend-object!, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([obj fn-map]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 2187, :end-line 2187, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj fn-map])), :doc "Takes a JavaScript object and a map of names to functions and\n  attaches said functions as methods on the object.  Any references to\n  JavaScript's implicit this (via the this-as macro) will resolve to the\n  object that the function is attached.", :test true}, do-assoc {:protocol-inline nil, :private true, :name cljs.core/do-assoc, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([pv level node i val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/VectorNode, :variadic false, :max-fixed-arity 5}), :line 4130, :end-line 4130, :max-fixed-arity 5, :fn-var true, :arglists (quote ([pv level node i val])), :test true}, reset-meta! {:protocol-inline nil, :name cljs.core/reset-meta!, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([iref m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 8341, :end-line 8341, :max-fixed-arity 2, :fn-var true, :arglists (quote ([iref m])), :doc "Atomically resets the metadata for an atom", :test true}, ->KeySeq {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->KeySeq, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([mseq _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/KeySeq, :variadic false, :max-fixed-arity 2}), :line 7065, :end-line 7065, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mseq _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, IEquiv {:protocol-symbol true, :name cljs.core/IEquiv, :file "out/cljs/core.cljs", :end-column 21, :column 1, :line 315, :protocol-info {:methods {-equiv [[o other]]}}, :info nil, :end-line 315, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq js/Date cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/Keyword cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq number default cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/Atom cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/NeverEquiv cljs.core/LazyTransformer cljs.core/UUID cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :test true}, tree-map-kv-reduce {:protocol-inline nil, :private true, :name cljs.core/tree-map-kv-reduce, :variadic false, :file "out/cljs/core.cljs", :end-column 27, :method-params ([node f init]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 6498, :end-line 6498, :max-fixed-arity 3, :fn-var true, :arglists (quote ([node f init])), :test true}, cycle {:protocol-inline nil, :name cljs.core/cycle, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 1}), :line 3785, :end-line 3785, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a lazy (infinite!) sequence of repetitions of the items in coll.", :test true}, -deref {:protocol-inline nil, :protocol cljs.core/IDeref, :name cljs.core/-deref, :variadic false, :file "out/cljs/core.cljs", :end-column 10, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 297, :end-line 298, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o])), :test true}, empty? {:protocol-inline nil, :name cljs.core/empty?, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1431, :ret-tag boolean, :end-line 1431, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([coll])), :doc "Returns true if coll has no items - same as (not (seq coll)).\n  Please use the idiom (seq x) rather than (not (empty? x))", :test true}, short {:protocol-inline nil, :name cljs.core/short, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1882, :ret-tag number, :end-line 1882, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x])), :test true}, -clj->js {:protocol-inline nil, :protocol cljs.core/IEncodeJS, :name cljs.core/-clj->js, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 8502, :end-line 8503, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, -chunked-first {:protocol-inline nil, :protocol cljs.core/IChunkedSeq, :name cljs.core/-chunked-first, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 388, :end-line 389, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, filterv {:protocol-inline nil, :name cljs.core/filterv, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2}), :line 3951, :end-line 3951, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns a vector of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects.", :test true}, tv-editable-root {:protocol-inline nil, :private true, :name cljs.core/tv-editable-root, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/VectorNode, :variadic false, :max-fixed-arity 1}), :line 4598, :end-line 4598, :max-fixed-arity 1, :fn-var true, :arglists (quote ([node])), :test true}, hash {:protocol-inline nil, :name cljs.core/hash, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any number}, :variadic false, :max-fixed-arity 1}), :line 528, :end-line 528, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o])), :test true}, quot {:protocol-inline nil, :name cljs.core/quot, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([n d]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2008, :end-line 2008, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n d])), :doc "quot[ient] of dividing numerator by denominator.", :test true}, unchecked-double {:protocol-inline nil, :name cljs.core/unchecked-double, :variadic false, :file "out/cljs/core.cljs", :end-column 32, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1890, :ret-tag number, :end-line 1890, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x])), :test true}, ->ChunkedCons {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/->ChunkedCons, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([chunk more meta __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ChunkedCons, :variadic false, :max-fixed-arity 4}), :line 2597, :end-line 2597, :max-fixed-arity 4, :fn-var true, :arglists (quote ([chunk more meta __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}, :test true}, ranged-iterator {:protocol-inline nil, :name cljs.core/ranged-iterator, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([v start end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/RangedIterator, :variadic false, :max-fixed-arity 3}), :line 4166, :end-line 4166, :max-fixed-arity 3, :fn-var true, :arglists (quote ([v start end])), :test true}, ITransientVector {:protocol-symbol true, :name cljs.core/ITransientVector, :file "out/cljs/core.cljs", :end-column 31, :column 1, :line 375, :protocol-info {:methods {-assoc-n! [[tcoll n val]], -pop! [[tcoll]]}}, :info nil, :end-line 375, :impls #{cljs.core/TransientVector}, :test true}, key {:protocol-inline nil, :name cljs.core/key, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([map-entry]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 7128, :end-line 7128, :max-fixed-arity 1, :fn-var true, :arglists (quote ([map-entry])), :doc "Returns the key of the map entry.", :test true}, longs {:protocol-inline nil, :name cljs.core/longs, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1996, :end-line 1996, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, not= {:protocol-inline nil, :name cljs.core/not=, :variadic true, :file "out/cljs/core.cljs", :end-column 21, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1} {:tag boolean, :variadic false, :max-fixed-arity 2} {:tag boolean, :variadic true, :max-fixed-arity 2}), :line 2976, :ret-tag boolean, :end-line 2976, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Same as (not (= obj1 obj2))", :test true}, string? {:protocol-inline nil, :name cljs.core/string?, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 109, :ret-tag boolean, :end-line 109, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :test true}, es6-iterator {:protocol-inline nil, :name cljs.core/es6-iterator, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/ES6Iterator, :variadic false, :max-fixed-arity 1}), :line 729, :end-line 729, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, Delay {:num-fields 2, :protocols #{cljs.core/IPending cljs.core/IDeref}, :name cljs.core/Delay, :file "out/cljs/core.cljs", :end-column 16, :type true, :column 10, :line 8400, :record false, :end-line 8400, :skip-protocol-flag #{cljs.core/IPending cljs.core/IDeref}}, pr-str-with-opts {:protocol-inline nil, :name cljs.core/pr-str-with-opts, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([objs opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil string}, :variadic false, :max-fixed-arity 2}), :line 8120, :end-line 8120, :max-fixed-arity 2, :fn-var true, :arglists (quote ([objs opts])), :doc "Prints a sequence of objects to a string, observing all the\n  options given in opts", :test true}, m3-C2 {:file "out/cljs/core.cljs", :line 455, :column 1, :end-line 455, :end-column 12, :test true, :name cljs.core/m3-C2}, ->Symbol {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :name cljs.core/->Symbol, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([ns name str _hash _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Symbol, :variadic false, :max-fixed-arity 5}), :line 581, :end-line 581, :max-fixed-arity 5, :fn-var true, :arglists (quote ([ns name str _hash _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :test true}, *print-newline* {:file "out/cljs/core.cljs", :line 33, :column 1, :end-line 33, :end-column 32, :dynamic true, :test true, :name cljs.core/*print-newline*}, unchecked-multiply-int {:protocol-inline nil, :name cljs.core/unchecked-multiply-int, :variadic true, :file "out/cljs/core.cljs", :end-column 38, :method-params ([] [x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 0} {:variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 1932, :ret-tag number, :end-line 1932, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the product of nums. (*) returns 1.", :test true}, chunk-rest {:protocol-inline nil, :name cljs.core/chunk-rest, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 2675, :end-line 2675, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :test true}, remove-all-methods {:protocol-inline nil, :name cljs.core/remove-all-methods, :variadic false, :file "out/cljs/core.cljs", :end-column 26, :method-params ([multifn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 8996, :end-line 8996, :max-fixed-arity 1, :fn-var true, :arglists (quote ([multifn])), :doc "Removes all of the methods of multimethod.", :test true}, trampoline {:protocol-inline nil, :name cljs.core/trampoline, :variadic true, :file "out/cljs/core.cljs", :end-column 18, :method-params ([f] [f args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1} {:tag any, :variadic true, :max-fixed-arity 1}), :line 8588, :end-line 8588, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f] [f & args])), :doc "trampoline can be used to convert algorithms requiring mutual\n  recursion without stack consumption. Calls f with supplied args, if\n  any. If f returns a fn, calls that fn with no arguments, and\n  continues to repeat, until the return value is not a fn, then\n  returns that non-fn value. Note that if you want to return a fn as a\n  final value, you must wrap it in some data structure and unpack it\n  after trampoline returns.", :test true}, pr-opts {:protocol-inline nil, :private true, :name cljs.core/pr-opts, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/IMap, :variadic false, :max-fixed-arity 0}), :line 42, :end-line 42, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :test true}, *1 {:file "out/cljs/core.cljs", :line 59, :column 1, :end-line 61, :end-column 6, :doc "bound in a repl thread to the most recent value printed", :test true, :name cljs.core/*1}, vec {:protocol-inline nil, :name cljs.core/vec, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 4378, :end-line 4378, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, *print-meta* {:file "out/cljs/core.cljs", :line 35, :column 1, :end-line 35, :end-column 29, :dynamic true, :test true, :name cljs.core/*print-meta*}, -notify-watches {:protocol-inline nil, :protocol cljs.core/IWatchable, :name cljs.core/-notify-watches, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([this oldval newval]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 357, :end-line 358, :max-fixed-arity 3, :fn-var true, :arglists (quote ([this oldval newval])), :test true}, MultiFn {:num-fields 8, :protocols #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}, :name cljs.core/MultiFn, :file "out/cljs/core.cljs", :end-column 18, :type true, :column 10, :line 8811, :record false, :end-line 8811, :skip-protocol-flag #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}}, int {:protocol-inline nil, :name cljs.core/int, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 1969, :end-line 1969, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to int by stripping decimal places.", :test true}, ->ValSeq {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->ValSeq, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([mseq _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ValSeq, :variadic false, :max-fixed-arity 2}), :line 7133, :end-line 7133, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mseq _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, rand {:protocol-inline nil, :name cljs.core/rand, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([] [n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 0} {:tag number, :variadic false, :max-fixed-arity 1}), :line 8604, :end-line 8604, :max-fixed-arity 1, :fn-var true, :arglists (quote ([] [n])), :doc "Returns a random floating point number between 0 (inclusive) and\n  n (default 1) (exclusive).", :test true}, second {:protocol-inline nil, :name cljs.core/second, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 1080, :end-line 1080, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (first (next x))", :test true}, IEditableCollection {:protocol-symbol true, :name cljs.core/IEditableCollection, :file "out/cljs/core.cljs", :end-column 34, :column 1, :line 362, :protocol-info {:methods {-as-transient [[coll]]}}, :info nil, :end-line 362, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/PersistentArrayMap cljs.core/PersistentVector cljs.core/PersistentHashSet}, :test true}, hash-combine {:protocol-inline nil, :name cljs.core/hash-combine, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([seed hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 551, :end-line 551, :max-fixed-arity 2, :fn-var true, :arglists (quote ([seed hash])), :test true}, > {:protocol-inline nil, :name cljs.core/>, :variadic true, :file "out/cljs/core.cljs", :end-column 18, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1} {:tag boolean, :variadic false, :max-fixed-arity 2} {:tag boolean, :variadic true, :max-fixed-arity 2}), :line 1830, :ret-tag boolean, :end-line 1830, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false.", :test true}, -name {:protocol-inline nil, :protocol cljs.core/INamed, :name cljs.core/-name, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 395, :ret-tag string, :end-line 396, :max-fixed-arity 1, :tag string, :fn-var true, :arglists (quote ([x])), :test true}, replace {:protocol-inline nil, :name cljs.core/replace, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([smap] [smap coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag #{nil any cljs.core/LazySeq}, :variadic false, :max-fixed-arity 2}), :line 7507, :end-line 7507, :max-fixed-arity 2, :fn-var true, :arglists (quote ([smap] [smap coll])), :doc "Given a map of replacement pairs and a vector/collection, returns a\n  vector/seq with any elements = a key in smap replaced with the\n  corresponding val in smap.  Returns a transducer when no collection\n  is provided.", :test true}, ->Subvec {:protocol-inline nil, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->Subvec, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([meta v start end __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Subvec, :variadic false, :max-fixed-arity 5}), :line 4475, :end-line 4475, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta v start end __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :test true}, associative? {:protocol-inline nil, :name cljs.core/associative?, :variadic false, :file "out/cljs/core.cljs", :end-column 29, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1451, :ret-tag boolean, :end-line 1451, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll implements Associative", :test true}, unchecked-int {:protocol-inline nil, :name cljs.core/unchecked-int, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 1974, :end-line 1974, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to int by stripping decimal places.", :test true}, js-keys {:protocol-inline nil, :name cljs.core/js-keys, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1}), :line 1490, :end-line 1490, :max-fixed-arity 1, :fn-var true, :arglists (quote ([obj])), :test true}, ES6EntriesIterator {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/ES6EntriesIterator, :file "out/cljs/core.cljs", :end-column 29, :type true, :column 10, :line 5059, :record false, :end-line 5059, :skip-protocol-flag nil}, keyword? {:protocol-inline nil, :name cljs.core/keyword?, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 2447, :ret-tag boolean, :end-line 2447, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :test true}, array-iter {:protocol-inline nil, :name cljs.core/array-iter, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/ArrayIter, :variadic false, :max-fixed-arity 1}), :line 3015, :end-line 3015, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, force {:protocol-inline nil, :name cljs.core/force, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 8416, :end-line 8416, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "If x is a Delay, returns the (possibly cached) value of its expression, else returns x", :test true}, group-by {:protocol-inline nil, :name cljs.core/group-by, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2}), :line 8621, :end-line 8621, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f coll])), :doc "Returns a map of the elements of coll keyed by the result of\n  f on each element. The value at each key will be a vector of the\n  corresponding elements, in the order they appeared in coll.", :test true}, -rseq {:protocol-inline nil, :protocol cljs.core/IReversible, :name cljs.core/-rseq, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 333, :ret-tag clj, :end-line 334, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([coll])), :test true}, prn {:protocol-inline nil, :name cljs.core/prn, :variadic true, :file "out/cljs/core.cljs", :end-column 11, :method-params ([objs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic true, :max-fixed-arity 0}), :line 8190, :end-line 8190, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& objs])), :doc "Same as pr followed by (newline).", :test true}, tv-pop-tail {:protocol-inline nil, :private true, :name cljs.core/tv-pop-tail, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([tv level node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil cljs.core/VectorNode clj-nil}, :variadic false, :max-fixed-arity 3}), :line 4618, :end-line 4618, :max-fixed-arity 3, :fn-var true, :arglists (quote ([tv level node])), :test true}, ->Atom {:protocol-inline nil, :protocols #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IMeta cljs.core/IDeref}, :name cljs.core/->Atom, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([state meta validator watches]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Atom, :variadic false, :max-fixed-arity 4}), :line 3406, :end-line 3406, :max-fixed-arity 4, :fn-var true, :arglists (quote ([state meta validator watches])), :skip-protocol-flag #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/IMeta cljs.core/IDeref}, :test true}, PersistentHashMap {:num-fields 6, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/PersistentHashMap, :file "out/cljs/core.cljs", :end-column 28, :type true, :column 10, :line 6104, :record false, :declared true, :end-line 6104, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :test true}, unchecked-multiply {:protocol-inline nil, :name cljs.core/unchecked-multiply, :variadic true, :file "out/cljs/core.cljs", :end-column 34, :method-params ([] [x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 0} {:variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 1925, :ret-tag number, :end-line 1925, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the product of nums. (*) returns 1.", :test true}, ArrayNodeSeq {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/ArrayNodeSeq, :file "out/cljs/core.cljs", :end-column 23, :type true, :column 10, :line 6049, :record false, :end-line 6049, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, even? {:protocol-inline nil, :name cljs.core/even?, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 3248, :ret-tag boolean, :end-line 3248, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :doc "Returns true if n is even, throws an exception if n is not an integer", :test true}, es6-iterator-seq {:protocol-inline nil, :name cljs.core/es6-iterator-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([iter]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 744, :end-line 744, :max-fixed-arity 1, :fn-var true, :arglists (quote ([iter])), :test true}, unchecked-dec {:protocol-inline nil, :name cljs.core/unchecked-dec, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 1906, :end-line 1906, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, hash-collision-node-find-index {:protocol-inline nil, :private true, :name cljs.core/hash-collision-node-find-index, :variadic false, :file "out/cljs/core.cljs", :end-column 39, :method-params ([arr cnt key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 3}), :line 5861, :end-line 5861, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr cnt key])), :test true}, persistent-array-map-seq {:protocol-inline nil, :name cljs.core/persistent-array-map-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 32, :method-params ([arr i _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/PersistentArrayMapSeq clj-nil}, :variadic false, :max-fixed-arity 3}), :line 5216, :end-line 5216, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr i _meta])), :test true}, RangeIterator {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/RangeIterator, :file "out/cljs/core.cljs", :end-column 24, :type true, :column 10, :line 7676, :record false, :end-line 7676, :skip-protocol-flag nil}, MultiStepper {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/MultiStepper, :file "out/cljs/core.cljs", :end-column 23, :type true, :column 10, :line 3085, :record false, :end-line 3085, :skip-protocol-flag nil}, double-array {:protocol-inline nil, :name cljs.core/double-array, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([size-or-seq] [size init-val-or-seq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1} {:tag array, :variadic false, :max-fixed-arity 2}), :line 2746, :end-line 2746, :max-fixed-arity 2, :fn-var true, :arglists (quote ([size-or-seq] [size init-val-or-seq])), :test true}, ->EmptyList {:protocol-inline nil, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->EmptyList, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/EmptyList, :variadic false, :max-fixed-arity 1}), :line 2260, :end-line 2260, :max-fixed-arity 1, :fn-var true, :arglists (quote ([meta])), :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, seq-reduce {:protocol-inline nil, :private true, :name cljs.core/seq-reduce, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([f coll] [f val coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 1669, :end-line 1669, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f coll] [f val coll])), :test true}, spread {:protocol-inline nil, :name cljs.core/spread, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([arglist]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{seq cljs.core/Cons clj-nil}, :variadic false, :max-fixed-arity 1}), :line 2794, :end-line 2794, :max-fixed-arity 1, :fn-var true, :arglists (quote ([arglist])), :test true}, balance-left {:protocol-inline nil, :private true, :name cljs.core/balance-left, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([key val ins right]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/BlackNode cljs.core/RedNode}, :variadic false, :max-fixed-arity 4}), :line 6413, :end-line 6413, :max-fixed-arity 4, :fn-var true, :arglists (quote ([key val ins right])), :test true}, rseq {:protocol-inline nil, :name cljs.core/rseq, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 2319, :ret-tag seq, :end-line 2319, :max-fixed-arity 1, :tag seq, :fn-var true, :arglists (quote ([coll])), :test true}, ex-cause {:protocol-inline nil, :name cljs.core/ex-cause, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([ex]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 9078, :end-line 9078, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ex])), :doc "Alpha - subject to change.\n  Returns exception cause (an Error / ExceptionInfo) if ex is an\n  ExceptionInfo.\n  Otherwise returns nil.", :test true}, IReset {:protocol-symbol true, :name cljs.core/IReset, :file "out/cljs/core.cljs", :end-column 21, :column 1, :line 401, :protocol-info {:methods {-reset! [[o new-value]]}}, :info nil, :end-line 401, :impls #{}, :test true}, IEmptyableCollection {:protocol-symbol true, :name cljs.core/IEmptyableCollection, :file "out/cljs/core.cljs", :end-column 35, :column 1, :line 250, :protocol-info {:methods {-empty [[coll]]}}, :info nil, :end-line 250, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :test true}, array-map-index-of {:protocol-inline nil, :private true, :name cljs.core/array-map-index-of, :variadic false, :file "out/cljs/core.cljs", :end-column 27, :method-params ([m k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 5132, :end-line 5132, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m k])), :test true}, ex-message {:protocol-inline nil, :name cljs.core/ex-message, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([ex]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 9070, :end-line 9070, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ex])), :doc "Alpha - subject to change.\n  Returns the message attached to the given Error / ExceptionInfo object.\n  For non-Errors returns nil.", :test true}, string-print {:protocol-inline nil, :name cljs.core/string-print, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 1}), :line 8010, :end-line 8010, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, float {:protocol-inline nil, :name cljs.core/float, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1883, :ret-tag number, :end-line 1883, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x])), :test true}, fixture2 {:file "out/cljs/core.cljs", :line 8396, :column 1, :end-line 8396, :end-column 15, :test true, :name cljs.core/fixture2}, IRecord {:protocol-symbol true, :name cljs.core/IRecord, :file "out/cljs/core.cljs", :end-column 22, :column 1, :line 330, :protocol-info {:methods {}}, :info nil, :end-line 330, :impls #{}, :test true}, pr-str {:protocol-inline nil, :name cljs.core/pr-str, :variadic true, :file "out/cljs/core.cljs", :end-column 14, :method-params ([objs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil string}, :variadic true, :max-fixed-arity 0}), :line 8148, :end-line 8148, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& objs])), :doc "pr to a string, returning it. Fundamental entrypoint to IPrintWithWriter.", :test true}, first-array-for-longvec {:protocol-inline nil, :private true, :name cljs.core/first-array-for-longvec, :variadic false, :file "out/cljs/core.cljs", :end-column 32, :method-params ([pv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 4106, :end-line 4106, :max-fixed-arity 1, :fn-var true, :arglists (quote ([pv])), :test true}, es6-set-entries-iterator {:protocol-inline nil, :name cljs.core/es6-set-entries-iterator, :variadic false, :file "out/cljs/core.cljs", :end-column 32, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/ES6SetEntriesIterator, :variadic false, :max-fixed-arity 1}), :line 5081, :end-line 5081, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, concat {:protocol-inline nil, :name cljs.core/concat, :variadic true, :file "out/cljs/core.cljs", :end-column 14, :method-params ([] [x] [x y] [x y zs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 0} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2} {:tag cljs.core/LazySeq, :variadic true, :max-fixed-arity 2}), :line 2802, :end-line 2802, :max-fixed-arity 2, :fn-var true, :arglists (quote ([] [x] [x y] [x y & zs])), :doc "Returns a lazy seq representing the concatenation of the elements in the supplied colls.", :test true}, -methods {:protocol-inline nil, :protocol cljs.core/IMultiFn, :name cljs.core/-methods, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([mf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 8799, :end-line 8805, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mf])), :test true}, IDerefWithTimeout {:protocol-symbol true, :name cljs.core/IDerefWithTimeout, :file "out/cljs/core.cljs", :end-column 32, :column 1, :line 300, :protocol-info {:methods {-deref-with-timeout [[o msec timeout-val]]}}, :info nil, :end-line 300, :impls #{}, :test true}, symbol {:protocol-inline nil, :name cljs.core/symbol, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([name] [ns name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil cljs.core/Symbol}, :variadic false, :max-fixed-arity 1} {:tag cljs.core/Symbol, :variadic false, :max-fixed-arity 2}), :line 615, :end-line 615, :max-fixed-arity 2, :fn-var true, :arglists (quote ([name] [ns name])), :test true}, to-array-2d {:protocol-inline nil, :name cljs.core/to-array-2d, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1}), :line 2695, :end-line 2695, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a (potentially-ragged) 2-dimensional array\n  containing the contents of coll.", :test true}, Subvec {:num-fields 5, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/Subvec, :file "out/cljs/core.cljs", :end-column 17, :type true, :column 10, :line 4475, :record false, :end-line 4475, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, ExceptionInfo {:num-fields 3, :protocols #{}, :name cljs.core/ExceptionInfo, :file "out/cljs/core.cljs", :end-column 24, :type true, :column 10, :line 9047, :record false, :end-line 9047, :skip-protocol-flag nil}, mod {:protocol-inline nil, :name cljs.core/mod, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([n d]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2003, :end-line 2003, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n d])), :doc "Modulus of num and div. Truncates toward negative infinity.", :test true}, ISet {:protocol-symbol true, :name cljs.core/ISet, :file "out/cljs/core.cljs", :end-column 19, :column 1, :line 287, :protocol-info {:methods {-disjoin [[coll v]]}}, :info nil, :end-line 287, :impls #{cljs.core/PersistentHashSet cljs.core/PersistentTreeSet}, :test true}, pop {:protocol-inline nil, :name cljs.core/pop, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{clj clj-nil}, :variadic false, :max-fixed-arity 1}), :line 1409, :end-line 1409, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item.\n  Note - not the same as next/butlast.", :test true}, IPending {:protocol-symbol true, :name cljs.core/IPending, :file "out/cljs/core.cljs", :end-column 23, :column 1, :line 354, :protocol-info {:methods {-realized? [[d]]}}, :info nil, :end-line 354, :impls #{cljs.core/Delay}, :test true}, -entry-key {:protocol-inline nil, :protocol cljs.core/ISorted, :name cljs.core/-entry-key, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([coll entry]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 336, :end-line 339, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll entry])), :test true}, pop-tail {:protocol-inline nil, :private true, :name cljs.core/pop-tail, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([pv level node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/VectorNode clj-nil}, :variadic false, :max-fixed-arity 3}), :line 4140, :end-line 4140, :max-fixed-arity 3, :fn-var true, :arglists (quote ([pv level node])), :test true}, dissoc! {:protocol-inline nil, :name cljs.core/dissoc!, :variadic true, :file "out/cljs/core.cljs", :end-column 15, :method-params ([tcoll key] [tcoll key ks]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2} {:tag clj, :variadic true, :max-fixed-arity 2}), :line 2877, :end-line 2877, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tcoll key] [tcoll key & ks])), :doc "Returns a transient map that doesn't contain a mapping for key(s).", :test true}, reductions {:protocol-inline nil, :name cljs.core/reductions, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([f coll] [f init coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2} {:tag cljs.core/Cons, :variadic false, :max-fixed-arity 3}), :line 7860, :end-line 7860, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f coll] [f init coll])), :doc "Returns a lazy seq of the intermediate values of the reduction (as\n  per reduce) of coll by f, starting with init.", :test true}, indexed? {:protocol-inline nil, :name cljs.core/indexed?, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 927, :ret-tag boolean, :end-line 927, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll implements nth in constant time", :test true}, - {:protocol-inline nil, :name cljs.core/-, :variadic true, :file "out/cljs/core.cljs", :end-column 17, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 1783, :ret-tag number, :end-line 1783, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :test true}, -equiv {:protocol-inline nil, :protocol cljs.core/IEquiv, :name cljs.core/-equiv, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([o other]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 315, :ret-tag boolean, :end-line 316, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([o other])), :test true}, ->RangeIterator {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->RangeIterator, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([i end step]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/RangeIterator, :variadic false, :max-fixed-arity 3}), :line 7676, :end-line 7676, :max-fixed-arity 3, :fn-var true, :arglists (quote ([i end step])), :skip-protocol-flag nil, :test true}, ->ArrayNode {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->ArrayNode, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([edit cnt arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ArrayNode, :variadic false, :max-fixed-arity 3}), :line 5764, :end-line 5764, :max-fixed-arity 3, :fn-var true, :arglists (quote ([edit cnt arr])), :skip-protocol-flag nil, :test true}, assoc! {:protocol-inline nil, :name cljs.core/assoc!, :variadic true, :file "out/cljs/core.cljs", :end-column 14, :method-params ([tcoll key val] [tcoll key val kvs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 3} {:tag clj, :variadic true, :max-fixed-arity 3}), :line 2865, :end-line 2865, :max-fixed-arity 3, :fn-var true, :arglists (quote ([tcoll key val] [tcoll key val & kvs])), :doc "When applied to a transient map, adds mapping of key(s) to\n  val(s). When applied to a transient vector, sets the val at index.\n  Note - index must be <= (count vector). Returns coll.", :test true}, hash-set {:protocol-inline nil, :name cljs.core/hash-set, :variadic true, :file "out/cljs/core.cljs", :end-column 16, :method-params ([] [keys]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/ISet, :variadic false, :max-fixed-arity 0} {:tag clj, :variadic true, :max-fixed-arity 0}), :line 7491, :end-line 7491, :max-fixed-arity 0, :fn-var true, :arglists (quote ([] [& keys])), :test true}, reduce-kv {:protocol-inline nil, :name cljs.core/reduce-kv, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([f init coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 1735, :end-line 1735, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f init coll])), :doc "Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals.", :test true}, reset! {:file "out/cljs/core.cljs", :line 5492, :column 1, :end-line 5492, :end-column 56, :declared true, :test true, :name cljs.core/reset!}, name {:protocol-inline nil, :name cljs.core/name, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil string}, :variadic false, :max-fixed-arity 1}), :line 7544, :end-line 7544, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns the name String of a string, symbol or keyword.", :test true}, ->RedNode {:protocol-inline nil, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->RedNode, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([key val left right __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/RedNode, :variadic false, :max-fixed-arity 5}), :line 6618, :end-line 6618, :max-fixed-arity 5, :fn-var true, :arglists (quote ([key val left right __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :test true}, unchecked-array-for {:protocol-inline nil, :private true, :name cljs.core/unchecked-array-for, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([pv i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 4114, :end-line 4114, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pv i])), :test true}, Fn {:protocol-symbol true, :name cljs.core/Fn, :file "out/cljs/core.cljs", :end-column 17, :column 1, :line 216, :protocol-info {:methods {}}, :info nil, :end-line 216, :impls #{function cljs.core/MetaFn}, :test true}, ffirst {:protocol-inline nil, :name cljs.core/ffirst, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 1085, :end-line 1085, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (first (first x))", :test true}, sorted-set {:protocol-inline nil, :name cljs.core/sorted-set, :variadic true, :file "out/cljs/core.cljs", :end-column 18, :method-params ([keys]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic true, :max-fixed-arity 0}), :line 7495, :end-line 7495, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& keys])), :doc "Returns a new sorted set with supplied keys.", :test true}, pr-with-opts {:protocol-inline nil, :private true, :name cljs.core/pr-with-opts, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([objs opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 2}), :line 8137, :end-line 8137, :max-fixed-arity 2, :fn-var true, :arglists (quote ([objs opts])), :doc "Prints a sequence of objects using string-print, observing all\n  the options given in opts", :test true}, PersistentTreeMap {:num-fields 5, :protocols #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/PersistentTreeMap, :file "out/cljs/core.cljs", :end-column 28, :type true, :column 10, :line 6868, :record false, :end-line 6868, :skip-protocol-flag #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, ->PersistentTreeMap {:protocol-inline nil, :protocols #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/->PersistentTreeMap, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([comp tree cnt meta __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentTreeMap, :variadic false, :max-fixed-arity 5}), :line 6868, :end-line 6868, :max-fixed-arity 5, :fn-var true, :arglists (quote ([comp tree cnt meta __hash])), :skip-protocol-flag #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :test true}, array-reduce {:protocol-inline nil, :private true, :name cljs.core/array-reduce, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([arr f] [arr f val] [arr f val idx]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic false, :max-fixed-arity 3} {:tag #{nil any}, :variadic false, :max-fixed-arity 4}), :line 890, :end-line 890, :max-fixed-arity 4, :fn-var true, :arglists (quote ([arr f] [arr f val] [arr f val idx])), :test true}, counted? {:protocol-inline nil, :name cljs.core/counted?, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 923, :ret-tag boolean, :end-line 923, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll implements count in constant time", :test true}, println {:protocol-inline nil, :name cljs.core/println, :variadic true, :file "out/cljs/core.cljs", :end-column 15, :method-params ([objs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic true, :max-fixed-arity 0}), :line 8178, :end-line 8178, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& objs])), :doc "Same as print followed by (newline)", :test true}, assoc-in {:protocol-inline nil, :name cljs.core/assoc-in, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([m p__12171 v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 3}), :line 4003, :end-line 4003, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m [k & ks] v])), :doc "Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created.", :test true}, PersistentHashSet {:num-fields 3, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :name cljs.core/PersistentHashSet, :file "out/cljs/core.cljs", :end-column 28, :type true, :column 10, :line 7243, :record false, :end-line 7243, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}}, bit-test {:protocol-inline nil, :name cljs.core/bit-test, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 2055, :ret-tag boolean, :end-line 2055, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x n])), :doc "Test bit at index n", :test true}, TransientHashMap {:num-fields 5, :protocols #{cljs.core/ITransientMap cljs.core/Object cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/TransientHashMap, :file "out/cljs/core.cljs", :end-column 27, :type true, :column 10, :line 6243, :record false, :declared true, :end-line 6243, :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :test true}, ->PersistentHashMap {:protocol-inline nil, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/->PersistentHashMap, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([meta cnt root has-nil? nil-val __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentHashMap, :variadic false, :max-fixed-arity 6}), :line 6104, :end-line 6104, :max-fixed-arity 6, :fn-var true, :arglists (quote ([meta cnt root has-nil? nil-val __hash])), :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :test true}, ISwap {:protocol-symbol true, :name cljs.core/ISwap, :file "out/cljs/core.cljs", :end-column 20, :column 1, :line 404, :protocol-info {:methods {-swap! [[o f] [o f a] [o f a b] [o f a b xs]]}}, :info nil, :end-line 404, :impls #{}, :test true}, ChunkedCons {:num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/ChunkedCons, :file "out/cljs/core.cljs", :end-column 22, :type true, :column 10, :line 2597, :record false, :declared true, :end-line 2597, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}, :test true}, memoize {:protocol-inline nil, :name cljs.core/memoize, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1}), :line 8573, :end-line 8573, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Returns a memoized version of a referentially transparent function. The\n  memoized version of the function keeps a cache of the mapping from arguments\n  to results and, when calls with the same arguments are repeated often, has\n  higher performance at the expense of higher memory use.", :test true}, alter-meta! {:protocol-inline nil, :name cljs.core/alter-meta!, :variadic true, :file "out/cljs/core.cljs", :end-column 19, :method-params ([iref f args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic true, :max-fixed-arity 2}), :line 8332, :end-line 8332, :max-fixed-arity 2, :fn-var true, :arglists (quote ([iref f & args])), :doc "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n  (apply f its-current-meta args)\n\n  f must be free of side-effects", :test true}, ->StringBufferWriter {:protocol-inline nil, :protocols #{cljs.core/IWriter}, :name cljs.core/->StringBufferWriter, :variadic false, :file "out/cljs/core.cljs", :end-column 29, :method-params ([sb]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/StringBufferWriter, :variadic false, :max-fixed-arity 1}), :line 415, :end-line 415, :max-fixed-arity 1, :fn-var true, :arglists (quote ([sb])), :skip-protocol-flag #{cljs.core/IWriter}, :test true}, zero? {:protocol-inline nil, :name cljs.core/zero?, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 2100, :ret-tag boolean, :end-line 2100, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :test true}, tv-ensure-editable {:protocol-inline nil, :private true, :name cljs.core/tv-ensure-editable, :variadic false, :file "out/cljs/core.cljs", :end-column 27, :method-params ([edit node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil cljs.core/VectorNode}, :variadic false, :max-fixed-arity 2}), :line 4593, :end-line 4593, :max-fixed-arity 2, :fn-var true, :arglists (quote ([edit node])), :test true}, *main-cli-fn* {:file "out/cljs/core.cljs", :line 127, :column 1, :end-line 131, :end-column 17, :doc "When compiled for a command-line target, whatever\n  function *main-fn* is set to will be called with the command-line\n  argv as arguments", :test true, :name cljs.core/*main-cli-fn*}, -assoc-n {:protocol-inline nil, :protocol cljs.core/IVector, :name cljs.core/-assoc-n, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([coll n val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 294, :ret-tag clj, :end-line 295, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([coll n val])), :test true}, unchecked-dec-int {:protocol-inline nil, :name cljs.core/unchecked-dec-int, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 1909, :end-line 1909, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, hash-imap {:protocol-inline nil, :private true, :name cljs.core/hash-imap, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 2166, :end-line 2166, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :test true}, dominates {:protocol-inline nil, :private true, :name cljs.core/dominates, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([x y prefer-table]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{boolean clj-nil}, :variadic false, :max-fixed-arity 3}), :line 8770, :end-line 8770, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x y prefer-table])), :test true}, persistent! {:protocol-inline nil, :name cljs.core/persistent!, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([tcoll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 2845, :end-line 2845, :max-fixed-arity 1, :fn-var true, :arglists (quote ([tcoll])), :doc "Returns a new, persistent version of the transient collection, in\n  constant time. The transient collection cannot be used after this\n  call, any such use will throw an exception.", :test true}, set-print-fn! {:protocol-inline nil, :name cljs.core/set-print-fn!, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 28, :end-line 28, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Set *print-fn* to f.", :test true}, nnext {:protocol-inline nil, :name cljs.core/nnext, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag seq, :variadic false, :max-fixed-arity 1}), :line 1100, :end-line 1100, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (next (next x))", :test true}, Box {:num-fields 1, :protocols #{}, :name cljs.core/Box, :file "out/cljs/core.cljs", :end-column 14, :type true, :column 10, :line 5490, :record false, :end-line 5490, :skip-protocol-flag nil}, balance-right {:protocol-inline nil, :private true, :name cljs.core/balance-right, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([key val left ins]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/BlackNode cljs.core/RedNode}, :variadic false, :max-fixed-arity 4}), :line 6438, :end-line 6438, :max-fixed-arity 4, :fn-var true, :arglists (quote ([key val left ins])), :test true}, throw-no-method-error {:protocol-inline nil, :private true, :name cljs.core/throw-no-method-error, :variadic false, :file "out/cljs/core.cljs", :end-column 30, :method-params ([name dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag ignore, :variadic false, :max-fixed-arity 2}), :line 8808, :end-line 8808, :max-fixed-arity 2, :fn-var true, :arglists (quote ([name dispatch-val])), :test true}, add-watch {:protocol-inline nil, :name cljs.core/add-watch, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([iref key f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 3}), :line 8346, :end-line 8346, :max-fixed-arity 3, :fn-var true, :arglists (quote ([iref key f])), :doc "Alpha - subject to change.\n\n  Adds a watch function to an atom reference. The watch fn must be a\n  fn of 4 args: a key, the reference, its old-state, its\n  new-state. Whenever the reference's state might have been changed,\n  any registered watches will have their functions called. The watch\n  fn will be called synchronously. Note that an atom's state\n  may have changed again prior to the fn call, so use old/new-state\n  rather than derefing the reference. Keys must be unique per\n  reference, and can be used to remove the watch with remove-watch,\n  but are otherwise considered opaque by the watch mechanism.  Bear in\n  mind that regardless of the result or action of the watch fns the\n  atom's value will change.  Example:\n\n      (def a (atom 0))\n      (add-watch a :inc (fn [k r o n] (assert (== 0 n))))\n      (swap! a inc)\n      ;; Assertion Error\n      (deref a)\n      ;=> 1", :test true}, not-every? {:protocol-inline nil, :name cljs.core/not-every?, :variadic false, :file "out/cljs/core.cljs", :end-column 27, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 3229, :ret-tag boolean, :end-line 3229, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns false if (pred x) is logical true for every x in\n  coll, else true.", :test true}, rem {:protocol-inline nil, :name cljs.core/rem, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([n d]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2014, :end-line 2014, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n d])), :doc "remainder of dividing numerator by denominator.", :test true}, pr-sb-with-opts {:protocol-inline nil, :private true, :name cljs.core/pr-sb-with-opts, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([objs opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag goog/string.StringBuffer, :variadic false, :max-fixed-arity 2}), :line 8113, :end-line 8113, :max-fixed-arity 2, :fn-var true, :arglists (quote ([objs opts])), :test true}, BitmapIndexedNode {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/BitmapIndexedNode, :file "out/cljs/core.cljs", :end-column 28, :type true, :column 10, :line 5553, :record false, :end-line 5553, :skip-protocol-flag nil}, ->NodeSeq {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->NodeSeq, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([meta nodes i s __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/NodeSeq, :variadic false, :max-fixed-arity 5}), :line 5986, :end-line 5986, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta nodes i s __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, some {:protocol-inline nil, :name cljs.core/some, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 2}), :line 3234, :end-line 3234, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)", :test true}, INamed {:protocol-symbol true, :name cljs.core/INamed, :file "out/cljs/core.cljs", :end-column 21, :column 1, :line 395, :protocol-info {:methods {-name [[x]], -namespace [[x]]}}, :info nil, :end-line 395, :impls #{cljs.core/MultiFn cljs.core/Keyword cljs.core/Symbol}, :test true}, ->Box {:protocol-inline nil, :protocols #{}, :name cljs.core/->Box, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Box, :variadic false, :max-fixed-arity 1}), :line 5490, :end-line 5490, :max-fixed-arity 1, :fn-var true, :arglists (quote ([val])), :skip-protocol-flag nil, :test true}, IReduce {:protocol-symbol true, :name cljs.core/IReduce, :file "out/cljs/core.cljs", :end-column 22, :column 1, :line 309, :protocol-info {:methods {-reduce [[coll f] [coll f start]]}}, :info nil, :end-line 309, :impls #{cljs.core/Cons cljs.core/Eduction cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/ArrayChunk cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :test true}, drop {:protocol-inline nil, :name cljs.core/drop, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([n] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 3723, :end-line 3723, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n] [n coll])), :doc "Returns a lazy sequence of all but the first n items in coll.\n  Returns a stateful transducer when no collection is provided.", :test true}, js-obj {:protocol-inline nil, :name cljs.core/js-obj, :variadic true, :file "out/cljs/core.cljs", :end-column 14, :method-params ([] [keyvals]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag object, :variadic false, :max-fixed-arity 0} {:tag any, :variadic true, :max-fixed-arity 0}), :line 1484, :end-line 1484, :max-fixed-arity 0, :fn-var true, :arglists (quote ([] [& keyvals])), :test true}, ITransientCollection {:protocol-symbol true, :name cljs.core/ITransientCollection, :file "out/cljs/core.cljs", :end-column 35, :column 1, :line 365, :protocol-info {:methods {-conj! [[tcoll val]], -persistent! [[tcoll]]}}, :info nil, :end-line 365, :impls #{cljs.core/TransientVector cljs.core/TransientHashMap cljs.core/TransientArrayMap cljs.core/TransientHashSet}, :test true}, Atom {:num-fields 4, :protocols #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IMeta cljs.core/IDeref}, :name cljs.core/Atom, :file "out/cljs/core.cljs", :end-column 15, :type true, :column 10, :line 3406, :record false, :end-line 3406, :skip-protocol-flag #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/IMeta cljs.core/IDeref}}, nth {:protocol-inline nil, :name cljs.core/nth, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([coll n] [coll n not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any clj-nil}, :variadic false, :max-fixed-arity 2} {:tag #{nil any clj-nil}, :variadic false, :max-fixed-arity 3}), :line 1185, :end-line 1185, :max-fixed-arity 3, :fn-var true, :arglists (quote ([coll n] [coll n not-found])), :doc "Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences.", :test true}, sorted? {:protocol-inline nil, :name cljs.core/sorted?, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1459, :ret-tag boolean, :end-line 1459, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll satisfies ISorted", :test true}, nil? {:protocol-inline nil, :name cljs.core/nil?, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 85, :ret-tag boolean, :end-line 85, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is nil, false otherwise.", :test true}, split-at {:protocol-inline nil, :name cljs.core/split-at, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/IVector, :variadic false, :max-fixed-arity 2}), :line 3791, :end-line 3791, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n coll])), :doc "Returns a vector of [(take n coll) (drop n coll)]", :test true}, TransientHashSet {:num-fields 1, :protocols #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :name cljs.core/TransientHashSet, :file "out/cljs/core.cljs", :end-column 27, :type true, :column 10, :line 7338, :record false, :declared true, :end-line 7338, :skip-protocol-flag #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :test true}, array-map-extend-kv {:protocol-inline nil, :private true, :name cljs.core/array-map-extend-kv, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([m k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 3}), :line 5147, :end-line 5147, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m k v])), :test true}, prn-str-with-opts {:protocol-inline nil, :name cljs.core/prn-str-with-opts, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([objs opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil string}, :variadic false, :max-fixed-arity 2}), :line 8128, :end-line 8128, :max-fixed-arity 2, :fn-var true, :arglists (quote ([objs opts])), :doc "Same as pr-str-with-opts followed by (newline)", :test true}, not-native {:file "out/cljs/core.cljs", :line 76, :column 1, :end-line 76, :end-column 17, :test true, :name cljs.core/not-native}, random-sample {:protocol-inline nil, :name cljs.core/random-sample, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([prob] [prob coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 8466, :end-line 8466, :max-fixed-arity 2, :fn-var true, :arglists (quote ([prob] [prob coll])), :doc "Returns items from coll with random probability of prob (0.0 -\n  1.0).  Returns a transducer when no collection is provided.", :test true}, select-keys {:protocol-inline nil, :name cljs.core/select-keys, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([map keyseq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{clj cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 2}), :line 7225, :end-line 7225, :max-fixed-arity 2, :fn-var true, :arglists (quote ([map keyseq])), :doc "Returns a map containing only those entries in map whose key is in keys", :test true}, bit-and {:protocol-inline nil, :name cljs.core/bit-and, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2024, :end-line 2024, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x y])), :doc "Bitwise and", :test true}, bounded-count {:protocol-inline nil, :private true, :name cljs.core/bounded-count, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([s n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2786, :end-line 2786, :max-fixed-arity 2, :fn-var true, :arglists (quote ([s n])), :test true}, update {:protocol-inline nil, :name cljs.core/update, :variadic true, :file "out/cljs/core.cljs", :end-column 14, :method-params ([m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 3} {:tag clj, :variadic false, :max-fixed-arity 4} {:tag clj, :variadic false, :max-fixed-arity 5} {:tag clj, :variadic false, :max-fixed-arity 6} {:tag clj, :variadic true, :max-fixed-arity 6}), :line 4039, :end-line 4039, :max-fixed-arity 6, :fn-var true, :arglists (quote ([m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z & more])), :doc "'Updates' a value in an associative structure, where k is a\n  key and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  structure.  If the key does not exist, nil is passed as the old value.", :test true}, gensym_counter {:file "out/cljs/core.cljs", :line 8381, :column 1, :end-line 8381, :end-column 21, :test true, :name cljs.core/gensym_counter}, list* {:protocol-inline nil, :name cljs.core/list*, :variadic true, :file "out/cljs/core.cljs", :end-column 13, :method-params ([args] [a args] [a b args] [a b c args] [a b c d more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag seq, :variadic false, :max-fixed-arity 1} {:tag cljs.core/Cons, :variadic false, :max-fixed-arity 2} {:tag cljs.core/Cons, :variadic false, :max-fixed-arity 3} {:tag cljs.core/Cons, :variadic false, :max-fixed-arity 4} {:tag cljs.core/Cons, :variadic true, :max-fixed-arity 4}), :line 2827, :end-line 2827, :max-fixed-arity 4, :fn-var true, :arglists (quote ([args] [a args] [a b args] [a b c args] [a b c d & more])), :doc "Creates a new list containing the items prepended to the rest, the\n  last of which will be treated as a sequence.", :test true}, ->Keyword {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IPrintWithWriter}, :name cljs.core/->Keyword, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([ns name fqn _hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Keyword, :variadic false, :max-fixed-arity 4}), :line 2419, :end-line 2419, :max-fixed-arity 4, :fn-var true, :arglists (quote ([ns name fqn _hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IPrintWithWriter}, :test true}, update-in {:protocol-inline nil, :name cljs.core/update-in, :variadic true, :file "out/cljs/core.cljs", :end-column 17, :method-params ([m p__12174 f] [m p__12175 f a] [m p__12176 f a b] [m p__12177 f a b c] [m p__12178 f a b c args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 3} {:tag clj, :variadic false, :max-fixed-arity 4} {:tag clj, :variadic false, :max-fixed-arity 5} {:tag clj, :variadic false, :max-fixed-arity 6} {:tag clj, :variadic true, :max-fixed-arity 6}), :line 4012, :end-line 4012, :max-fixed-arity 6, :fn-var true, :arglists (quote ([m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c] [m [k & ks] f a b c & args])), :doc "'Updates' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created.", :test true}, prefer-method {:protocol-inline nil, :name cljs.core/prefer-method, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([multifn dispatch-val-x dispatch-val-y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 9006, :end-line 9006, :max-fixed-arity 3, :fn-var true, :arglists (quote ([multifn dispatch-val-x dispatch-val-y])), :doc "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y\n   when there is a conflict", :test true}, hash-symbol {:protocol-inline nil, :private true, :name cljs.core/hash-symbol, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([sym]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 564, :end-line 564, :max-fixed-arity 1, :fn-var true, :arglists (quote ([sym])), :test true}, ensure-reduced {:protocol-inline nil, :name cljs.core/ensure-reduced, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil cljs.core/Reduced}, :variadic false, :max-fixed-arity 1}), :line 841, :end-line 841, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "If x is already reduced?, returns it, else returns (reduced x)", :test true}, edit-and-set {:protocol-inline nil, :private true, :name cljs.core/edit-and-set, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([inode edit i a] [inode edit i a j b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 4} {:tag any, :variadic false, :max-fixed-arity 6}), :line 5524, :end-line 5524, :max-fixed-arity 6, :fn-var true, :arglists (quote ([inode edit i a] [inode edit i a j b])), :test true}, ->PersistentArrayMap {:protocol-inline nil, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->PersistentArrayMap, :variadic false, :file "out/cljs/core.cljs", :end-column 29, :method-params ([meta cnt arr __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentArrayMap, :variadic false, :max-fixed-arity 4}), :line 5231, :end-line 5231, :max-fixed-arity 4, :fn-var true, :arglists (quote ([meta cnt arr __hash])), :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}, :test true}, instance? {:protocol-inline nil, :name cljs.core/instance?, :variadic false, :file "out/cljs/core.cljs", :end-column 26, :method-params ([t o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 558, :ret-tag boolean, :end-line 558, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([t o])), :test true}, mix-collection-hash {:protocol-inline nil, :name cljs.core/mix-collection-hash, :variadic false, :file "out/cljs/core.cljs", :end-column 35, :method-params ([hash-basis count]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 752, :ret-tag number, :end-line 752, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([hash-basis count])), :doc "Mix final collection hash for ordered or unordered collections.\n   hash-basis is the combined collection hash, count is the number\n   of elements included in the basis. Note this is the hash code\n   consistent with =, different from .hashCode.\n   See http://clojure.org/data_structures#hash for full algorithms.", :test true}, re-find {:protocol-inline nil, :name cljs.core/re-find, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([re s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{clj any clj-nil}, :variadic false, :max-fixed-arity 2}), :line 7954, :end-line 7954, :max-fixed-arity 2, :fn-var true, :arglists (quote ([re s])), :doc "Returns the first regex match, if any, of s to re, using\n  re.exec(s). Returns a vector, containing first the matching\n  substring, then any capturing groups if the regular expression contains\n  capturing groups.", :test true}, run! {:protocol-inline nil, :name cljs.core/run!, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([proc coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2}), :line 8496, :end-line 8496, :max-fixed-arity 2, :fn-var true, :arglists (quote ([proc coll])), :doc "Runs the supplied procedure (via reduce), for purposes of side\n  effects, on successive items in the collection. Returns nil", :test true}, char-escapes {:file "out/cljs/core.cljs", :line 8017, :column 1, :end-line 8017, :end-column 29, :private true, :test true, :name cljs.core/char-escapes}, ES6Iterator {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/ES6Iterator, :file "out/cljs/core.cljs", :end-column 22, :type true, :column 10, :line 720, :record false, :end-line 720, :skip-protocol-flag nil}, val {:protocol-inline nil, :name cljs.core/val, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([map-entry]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 7196, :end-line 7196, :max-fixed-arity 1, :fn-var true, :arglists (quote ([map-entry])), :doc "Returns the value in the map entry.", :test true}, unchecked-add {:protocol-inline nil, :name cljs.core/unchecked-add, :variadic true, :file "out/cljs/core.cljs", :end-column 29, :method-params ([] [x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 0} {:variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 1892, :ret-tag number, :end-line 1892, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the sum of nums. (+) returns 0.", :test true}, not {:protocol-inline nil, :name cljs.core/not, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 96, :ret-tag boolean, :end-line 96, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is logical false, false otherwise.", :test true}, -vreset! {:protocol-inline nil, :protocol cljs.core/IVolatile, :name cljs.core/-vreset!, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([o new-value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 407, :end-line 408, :max-fixed-arity 2, :fn-var true, :arglists (quote ([o new-value])), :test true}, fn->comparator {:protocol-inline nil, :private true, :name cljs.core/fn->comparator, :variadic false, :file "out/cljs/core.cljs", :end-column 32, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{number function}, :variadic false, :max-fixed-arity 1}), :line 1628, :end-line 1628, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Given a fn that might be boolean valued or a comparator,\n   return a fn that is a comparator.", :test true}, with-meta {:protocol-inline nil, :name cljs.core/with-meta, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([o meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{clj cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 2}), :line 1386, :end-line 1386, :max-fixed-arity 2, :fn-var true, :arglists (quote ([o meta])), :doc "Returns an object of the same type and value as obj, with\n  map m as its metadata.", :test true}, unreduced {:protocol-inline nil, :name cljs.core/unreduced, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 846, :end-line 846, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "If x is reduced?, returns (deref x), else returns x", :test true}, type {:protocol-inline nil, :name cljs.core/type, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 133, :end-line 133, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, identical? {:protocol-inline nil, :name cljs.core/identical?, :variadic false, :file "out/cljs/core.cljs", :end-column 27, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 80, :ret-tag boolean, :end-line 80, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x y])), :doc "Tests if 2 arguments are the same object", :test true}, -namespace {:protocol-inline nil, :protocol cljs.core/INamed, :name cljs.core/-namespace, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 395, :ret-tag string, :end-line 397, :max-fixed-arity 1, :tag string, :fn-var true, :arglists (quote ([x])), :test true}, unchecked-divide-int {:protocol-inline nil, :name cljs.core/unchecked-divide-int, :variadic true, :file "out/cljs/core.cljs", :end-column 36, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 1912, :ret-tag number, :end-line 1912, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :test true}, swap-global-hierarchy! {:protocol-inline nil, :private true, :name cljs.core/swap-global-hierarchy!, :variadic true, :file "out/cljs/core.cljs", :end-column 31, :method-params ([f args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic true, :max-fixed-arity 1}), :line 8644, :end-line 8644, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f & args])), :test true}, max-key {:protocol-inline nil, :name cljs.core/max-key, :variadic true, :file "out/cljs/core.cljs", :end-column 15, :method-params ([k x] [k x y] [k x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 2} {:variadic false, :max-fixed-arity 3} {:tag #{nil any}, :variadic true, :max-fixed-arity 3}), :line 7565, :end-line 7565, :max-fixed-arity 3, :fn-var true, :arglists (quote ([k x] [k x y] [k x y & more])), :doc "Returns the x for which (k x), a number, is greatest.", :test true}, ->PersistentTreeSet {:protocol-inline nil, :protocols #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :name cljs.core/->PersistentTreeSet, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([meta tree-map __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentTreeSet, :variadic false, :max-fixed-arity 3}), :line 7375, :end-line 7375, :max-fixed-arity 3, :fn-var true, :arglists (quote ([meta tree-map __hash])), :skip-protocol-flag #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :test true}, ->ChunkBuffer {:protocol-inline nil, :protocols #{cljs.core/Object cljs.core/ICounted}, :name cljs.core/->ChunkBuffer, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([buf end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ChunkBuffer, :variadic false, :max-fixed-arity 2}), :line 2548, :end-line 2548, :max-fixed-arity 2, :fn-var true, :arglists (quote ([buf end])), :skip-protocol-flag #{cljs.core/ICounted}, :test true}, hash-string {:protocol-inline nil, :name cljs.core/hash-string, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil number}, :variadic false, :max-fixed-arity 1}), :line 519, :end-line 519, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k])), :test true}, ValSeq {:num-fields 2, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/ValSeq, :file "out/cljs/core.cljs", :end-column 17, :type true, :column 10, :line 7133, :record false, :end-line 7133, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -prefers {:protocol-inline nil, :protocol cljs.core/IMultiFn, :name cljs.core/-prefers, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([mf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 8799, :end-line 8806, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mf])), :test true}, set-validator! {:protocol-inline nil, :name cljs.core/set-validator!, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([iref val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 3500, :end-line 3500, :max-fixed-arity 2, :fn-var true, :arglists (quote ([iref val])), :doc "Sets the validator-fn for an atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an Error. If the current state\n  is not acceptable to the new validator, an Error will be thrown and the\n  validator will not be changed.", :test true}, array-map-index-of-equiv? {:protocol-inline nil, :private true, :name cljs.core/array-map-index-of-equiv?, :variadic false, :file "out/cljs/core.cljs", :end-column 34, :method-params ([arr m k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 3}), :line 5124, :end-line 5124, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr m k])), :test true}, -meta {:protocol-inline nil, :protocol cljs.core/IMeta, :name cljs.core/-meta, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 303, :ret-tag clj-or-nil, :end-line 304, :max-fixed-arity 1, :tag clj-or-nil, :fn-var true, :arglists (quote ([o])), :test true}, RedNode {:num-fields 5, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/RedNode, :file "out/cljs/core.cljs", :end-column 18, :type true, :column 10, :line 6618, :record false, :declared true, :end-line 6618, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :test true}, ->IndexedSeqIterator {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->IndexedSeqIterator, :variadic false, :file "out/cljs/core.cljs", :end-column 29, :method-params ([arr i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/IndexedSeqIterator, :variadic false, :max-fixed-arity 2}), :line 931, :end-line 931, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr i])), :skip-protocol-flag nil, :test true}, -add-method {:protocol-inline nil, :protocol cljs.core/IMultiFn, :name cljs.core/-add-method, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([mf dispatch-val method]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 8799, :end-line 8801, :max-fixed-arity 3, :fn-var true, :arglists (quote ([mf dispatch-val method])), :test true}, balance-left-del {:protocol-inline nil, :private true, :name cljs.core/balance-left-del, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([key val del right]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/BlackNode cljs.core/RedNode}, :variadic false, :max-fixed-arity 4}), :line 6460, :end-line 6460, :max-fixed-arity 4, :fn-var true, :arglists (quote ([key val del right])), :test true}, swap! {:protocol-inline nil, :name cljs.core/swap!, :variadic true, :file "out/cljs/core.cljs", :end-column 13, :method-params ([a f] [a f x] [a f x y] [a f x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic false, :max-fixed-arity 3} {:tag #{nil any}, :variadic false, :max-fixed-arity 4} {:tag #{nil any}, :variadic true, :max-fixed-arity 4}), :line 3469, :end-line 3469, :max-fixed-arity 4, :fn-var true, :arglists (quote ([a f] [a f x] [a f x y] [a f x y & more])), :doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in.", :test true}, vals {:protocol-inline nil, :name cljs.core/vals, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([hash-map]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/ValSeq clj-nil}, :variadic false, :max-fixed-arity 1}), :line 7190, :end-line 7190, :max-fixed-arity 1, :fn-var true, :arglists (quote ([hash-map])), :doc "Returns a sequence of the map's values.", :test true}, -chunked-next {:protocol-inline nil, :protocol cljs.core/IChunkedNext, :name cljs.core/-chunked-next, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 392, :end-line 393, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, unchecked-subtract {:protocol-inline nil, :name cljs.core/unchecked-subtract, :variadic true, :file "out/cljs/core.cljs", :end-column 34, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 1950, :ret-tag number, :end-line 1950, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :test true}, remove-pair {:protocol-inline nil, :private true, :name cljs.core/remove-pair, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([arr i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 2}), :line 5512, :end-line 5512, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr i])), :test true}, IMap {:protocol-symbol true, :name cljs.core/IMap, :file "out/cljs/core.cljs", :end-column 19, :column 1, :line 279, :protocol-info {:methods {-dissoc [[coll k]]}}, :info nil, :end-line 279, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/PersistentArrayMap cljs.core/PersistentTreeMap}, :test true}, ->SeqIter {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->SeqIter, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([_seq _next]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/SeqIter, :variadic false, :max-fixed-arity 2}), :line 3021, :end-line 3021, :max-fixed-arity 2, :fn-var true, :arglists (quote ([_seq _next])), :skip-protocol-flag nil, :test true}, sorted-set-by {:protocol-inline nil, :name cljs.core/sorted-set-by, :variadic true, :file "out/cljs/core.cljs", :end-column 21, :method-params ([comparator keys]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic true, :max-fixed-arity 1}), :line 7500, :end-line 7500, :max-fixed-arity 1, :fn-var true, :arglists (quote ([comparator & keys])), :doc "Returns a new sorted set with supplied keys, using the supplied comparator.", :test true}, PersistentVector {:num-fields 6, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/PersistentVector, :file "out/cljs/core.cljs", :end-column 27, :type true, :column 10, :line 4176, :record false, :end-line 4176, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, cloneable? {:protocol-inline nil, :name cljs.core/cloneable?, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 642, :end-line 642, :max-fixed-arity 1, :fn-var true, :arglists (quote ([value])), :test true}, hash-string* {:protocol-inline nil, :name cljs.core/hash-string*, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 502, :end-line 502, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :test true}, key-test {:protocol-inline nil, :name cljs.core/key-test, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([key other]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 5494, :ret-tag boolean, :end-line 5494, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([key other])), :test true}, ->LazyTransformer {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/->LazyTransformer, :variadic false, :file "out/cljs/core.cljs", :end-column 26, :method-params ([stepper first rest meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/LazyTransformer, :variadic false, :max-fixed-arity 4}), :line 3130, :end-line 3130, :max-fixed-arity 4, :fn-var true, :arglists (quote ([stepper first rest meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ISequential cljs.core/IWithMeta}, :test true}, -reset {:protocol-inline nil, :protocol cljs.core/IMultiFn, :name cljs.core/-reset, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([mf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 8799, :end-line 8800, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mf])), :test true}, true? {:protocol-inline nil, :name cljs.core/true?, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1522, :ret-tag boolean, :end-line 1522, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is the value true, false otherwise.", :test true}, array {:protocol-inline nil, :name cljs.core/array, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([var-args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 173, :ret-tag array, :end-line 173, :max-fixed-arity 1, :tag array, :fn-var true, :arglists (quote ([var-args])), :doc "Creates a new javascript array.\n@param {...*} var_args", :test true}, print {:protocol-inline nil, :name cljs.core/print, :variadic true, :file "out/cljs/core.cljs", :end-column 9, :method-params ([objs]), :protocol-impl nil, :arglists-meta (), :column 1, :methods ({:tag clj-nil, :variadic true, :max-fixed-arity 0}), :line 8166, :end-line 8169, :max-fixed-arity 0, :fn-var true, :arglists nil, :doc "Prints the object(s) using string-print.\n  print and println produce output for human consumption.", :test true}, -peek {:protocol-inline nil, :protocol cljs.core/IStack, :name cljs.core/-peek, :variadic false, :file "out/cljs/core.cljs", :end-column 10, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 290, :end-line 291, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, ISeq {:protocol-symbol true, :name cljs.core/ISeq, :file "out/cljs/core.cljs", :end-column 19, :column 1, :line 264, :protocol-info {:methods {-first [[coll]], -rest [[coll]]}}, :info nil, :end-line 264, :impls #{cljs.core/Cons cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/EmptyList cljs.core/LazySeq cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/ES6IteratorSeq cljs.core/PersistentArrayMapSeq cljs.core/List cljs.core/RSeq cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq}, :test true}, empty {:protocol-inline nil, :name cljs.core/empty, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 1132, :end-line 1132, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns an empty collection of the same category as coll, or nil", :test true}, remove-method {:protocol-inline nil, :name cljs.core/remove-method, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([multifn dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 9001, :end-line 9001, :max-fixed-arity 2, :fn-var true, :arglists (quote ([multifn dispatch-val])), :doc "Removes the method of multimethod associated with dispatch-value.", :test true}, PersistentQueueSeq {:num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/PersistentQueueSeq, :file "out/cljs/core.cljs", :end-column 29, :type true, :column 10, :line 4781, :record false, :end-line 4781, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}}, balance-right-del {:protocol-inline nil, :private true, :name cljs.core/balance-right-del, :variadic false, :file "out/cljs/core.cljs", :end-column 26, :method-params ([key val left del]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/BlackNode cljs.core/RedNode}, :variadic false, :max-fixed-arity 4}), :line 6479, :end-line 6479, :max-fixed-arity 4, :fn-var true, :arglists (quote ([key val left del])), :test true}, volatile! {:protocol-inline nil, :name cljs.core/volatile!, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/Volatile, :variadic false, :max-fixed-arity 1}), :line 3523, :end-line 3523, :max-fixed-arity 1, :fn-var true, :arglists (quote ([val])), :doc "Creates and returns a Volatile with an initial value of val.", :test true}, / {:protocol-inline nil, :name cljs.core//, :variadic true, :file "out/cljs/core.cljs", :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 1799, :ret-tag number, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :test true}, bitpos {:protocol-inline nil, :private true, :name cljs.core/bitpos, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([hash shift]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 5521, :end-line 5521, :max-fixed-arity 2, :fn-var true, :arglists (quote ([hash shift])), :test true}, bit-or {:protocol-inline nil, :name cljs.core/bit-or, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2028, :end-line 2028, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x y])), :doc "Bitwise or", :test true}, m3-fmix {:protocol-inline nil, :name cljs.core/m3-fmix, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([h1 len]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 463, :ret-tag number, :end-line 463, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([h1 len])), :test true}, vector {:protocol-inline nil, :name cljs.core/vector, :variadic true, :file "out/cljs/core.cljs", :end-column 14, :method-params ([args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{clj any}, :variadic true, :max-fixed-arity 0}), :line 4384, :end-line 4384, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& args])), :test true}, hash-coll {:protocol-inline nil, :private true, :name cljs.core/hash-coll, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any number}, :variadic false, :max-fixed-arity 1}), :line 2156, :end-line 2156, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, clone-and-set {:protocol-inline nil, :private true, :name cljs.core/clone-and-set, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([arr i a] [arr i a j b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 3} {:tag array, :variadic false, :max-fixed-arity 5}), :line 5503, :end-line 5503, :max-fixed-arity 5, :fn-var true, :arglists (quote ([arr i a] [arr i a j b])), :test true}, array->transient-hash-map {:protocol-inline nil, :private true, :name cljs.core/array->transient-hash-map, :variadic false, :file "out/cljs/core.cljs", :end-column 34, :method-params ([len arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2}), :line 5481, :end-line 5481, :max-fixed-arity 2, :fn-var true, :arglists (quote ([len arr])), :test true}, >= {:protocol-inline nil, :name cljs.core/>=, :variadic true, :file "out/cljs/core.cljs", :end-column 19, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1} {:tag boolean, :variadic false, :max-fixed-arity 2} {:tag boolean, :variadic true, :max-fixed-arity 2}), :line 1842, :ret-tag boolean, :end-line 1842, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false.", :test true}, ->TransientHashSet {:protocol-inline nil, :protocols #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :name cljs.core/->TransientHashSet, :variadic false, :file "out/cljs/core.cljs", :end-column 27, :method-params ([transient-map]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/TransientHashSet, :variadic false, :max-fixed-arity 1}), :line 7338, :end-line 7338, :max-fixed-arity 1, :fn-var true, :arglists (quote ([transient-map])), :skip-protocol-flag #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :test true}, drop-last {:protocol-inline nil, :name cljs.core/drop-last, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([s] [n s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 3746, :end-line 3746, :max-fixed-arity 2, :fn-var true, :arglists (quote ([s] [n s])), :doc "Return a lazy sequence of all but the last n (default 1) items in coll", :test true}, ->ArrayIter {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->ArrayIter, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([arr i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ArrayIter, :variadic false, :max-fixed-arity 2}), :line 3006, :end-line 3006, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr i])), :skip-protocol-flag nil, :test true}, object? {:protocol-inline nil, :name cljs.core/object?, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 104, :ret-tag boolean, :end-line 104, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :test true}, ->ArrayNodeSeq {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->ArrayNodeSeq, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([meta nodes i s __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ArrayNodeSeq, :variadic false, :max-fixed-arity 5}), :line 6049, :end-line 6049, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta nodes i s __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, tree-map-append {:protocol-inline nil, :private true, :name cljs.core/tree-map-append, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([left right]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil cljs.core/BlackNode cljs.core/RedNode}, :variadic false, :max-fixed-arity 2}), :line 6780, :end-line 6780, :max-fixed-arity 2, :fn-var true, :arglists (quote ([left right])), :test true}, not-empty {:protocol-inline nil, :name cljs.core/not-empty, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj-nil}, :variadic false, :max-fixed-arity 1}), :line 2983, :end-line 2983, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "If coll is empty, returns nil, else coll", :test true}, distinct {:protocol-inline nil, :name cljs.core/distinct, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 1}), :line 7524, :end-line 7524, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a lazy sequence of the elements of coll with duplicates removed", :test true}, partition {:protocol-inline nil, :name cljs.core/partition, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([n coll] [n step coll] [n step pad coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 3} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 4}), :line 3960, :end-line 3960, :max-fixed-arity 4, :fn-var true, :arglists (quote ([n coll] [n step coll] [n step pad coll])), :doc "Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition up to n items. In case there are\n  not enough padding elements, return a partition with less than n items.", :test true}, IMultiFn {:protocol-symbol true, :name cljs.core/IMultiFn, :file "out/cljs/core.cljs", :end-column 23, :column 1, :line 8799, :protocol-info {:methods {-reset [[mf]], -add-method [[mf dispatch-val method]], -remove-method [[mf dispatch-val]], -prefer-method [[mf dispatch-val dispatch-val-y]], -get-method [[mf dispatch-val]], -methods [[mf]], -prefers [[mf]]}}, :info nil, :end-line 8799, :impls #{cljs.core/MultiFn}, :test true}, ->t11986 {:protocol-inline nil, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/->t11986, :variadic false, :file "out/cljs/core.cljs", :method-params ([nil-iter meta11987]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column 3, :factory :positional, :methods ({:tag cljs.core/t11986, :variadic false, :max-fixed-arity 2}), :line 2988, :max-fixed-arity 2, :fn-var true, :arglists (quote ([nil-iter meta11987])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}, :test true}, fix {:protocol-inline nil, :private true, :name cljs.core/fix, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([q]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 1964, :ret-tag number, :end-line 1964, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([q])), :test true}, EmptyList {:num-fields 1, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/EmptyList, :file "out/cljs/core.cljs", :end-column 20, :type true, :column 10, :line 2260, :record false, :end-line 2260, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, IAssociative {:protocol-symbol true, :name cljs.core/IAssociative, :file "out/cljs/core.cljs", :end-column 27, :column 1, :line 274, :protocol-info {:methods {-contains-key? [[coll k]], -assoc [[coll k v]]}}, :info nil, :end-line 274, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/PersistentArrayMap cljs.core/BlackNode cljs.core/Subvec cljs.core/PersistentVector cljs.core/PersistentTreeMap cljs.core/RedNode}, :test true}, bit-flip {:protocol-inline nil, :name cljs.core/bit-flip, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2041, :end-line 2041, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Flip bit at index n", :test true}, long-array {:protocol-inline nil, :name cljs.core/long-array, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([size-or-seq] [size init-val-or-seq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1} {:tag array, :variadic false, :max-fixed-arity 2}), :line 2726, :end-line 2726, :max-fixed-arity 2, :fn-var true, :arglists (quote ([size-or-seq] [size init-val-or-seq])), :test true}, descendants {:protocol-inline nil, :name cljs.core/descendants, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([tag] [h tag]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj-nil}, :variadic false, :max-fixed-arity 1} {:tag #{nil clj-nil}, :variadic false, :max-fixed-arity 2}), :line 8683, :end-line 8683, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tag] [h tag])), :doc "Returns the immediate and indirect children of tag, through a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy. Note: does not work on JavaScript type inheritance\n  relationships.", :test true}, imul {:protocol-inline nil, :name cljs.core/imul, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 3, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 442, :ret-tag number, :end-line 442, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([a b])), :test true}, ->Delay {:protocol-inline nil, :protocols #{cljs.core/IPending cljs.core/IDeref}, :name cljs.core/->Delay, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([f value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Delay, :variadic false, :max-fixed-arity 2}), :line 8400, :end-line 8400, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f value])), :skip-protocol-flag #{cljs.core/IPending cljs.core/IDeref}, :test true}, array-for {:protocol-inline nil, :private true, :name cljs.core/array-for, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([pv i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 4125, :end-line 4125, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pv i])), :test true}, merge {:protocol-inline nil, :name cljs.core/merge, :variadic true, :file "out/cljs/core.cljs", :end-column 13, :method-params ([maps]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any clj-nil}, :variadic true, :max-fixed-arity 0}), :line 7201, :end-line 7201, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& maps])), :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping from\n  the latter (left-to-right) will be the mapping in the result.", :test true}, ISeqable {:protocol-symbol true, :name cljs.core/ISeqable, :file "out/cljs/core.cljs", :end-column 23, :column 1, :line 321, :protocol-info {:methods {-seq [[o]]}}, :info nil, :end-line 321, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/Eduction cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/ES6IteratorSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :test true}, js-mod {:protocol-inline nil, :name cljs.core/js-mod, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([n d]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 1998, :end-line 1998, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n d])), :doc "Modulus of num and div with original javascript behavior. i.e. bug for negative numbers", :test true}, integer? {:protocol-inline nil, :name cljs.core/integer?, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1547, :ret-tag boolean, :end-line 1547, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :doc "Returns true if n is an integer.", :test true}, MetaFn {:num-fields 2, :protocols #{cljs.core/IFn cljs.core/IMeta cljs.core/Fn cljs.core/IWithMeta}, :name cljs.core/MetaFn, :file "out/cljs/core.cljs", :end-column 17, :type true, :column 10, :line 1333, :record false, :end-line 1333, :skip-protocol-flag #{cljs.core/IFn cljs.core/IMeta cljs.core/IWithMeta}}, mapv {:protocol-inline nil, :name cljs.core/mapv, :variadic true, :file "out/cljs/core.cljs", :end-column 12, :method-params ([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 colls]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2} {:tag #{nil clj any cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 3} {:tag #{nil clj any cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 4} {:tag #{nil clj any cljs.core/MetaFn clj-nil}, :variadic true, :max-fixed-arity 4}), :line 3935, :end-line 3935, :max-fixed-arity 4, :fn-var true, :arglists (quote ([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls])), :doc "Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments.", :test true}, partition-all {:protocol-inline nil, :name cljs.core/partition-all, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([n] [n coll] [n step coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 3}), :line 7590, :end-line 7590, :max-fixed-arity 3, :fn-var true, :arglists (quote ([n] [n coll] [n step coll])), :doc "Returns a lazy sequence of lists like partition, but may include\n  partitions with fewer than n items at the end.  Returns a stateful\n  transducer when no collection is provided.", :test true}, partition-by {:protocol-inline nil, :name cljs.core/partition-by, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([f] [f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 7810, :end-line 7810, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f] [f coll])), :doc "Applies f to each value in coll, splitting it each time f returns a\n   new value.  Returns a lazy seq of partitions.  Returns a stateful\n   transducer when no collection is provided.", :test true}, array-map-index-of-identical? {:protocol-inline nil, :private true, :name cljs.core/array-map-index-of-identical?, :variadic false, :file "out/cljs/core.cljs", :end-column 38, :method-params ([arr m k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 3}), :line 5116, :end-line 5116, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr m k])), :test true}, ISequential {:protocol-symbol true, :name cljs.core/ISequential, :file "out/cljs/core.cljs", :end-column 26, :column 1, :line 324, :protocol-info {:methods {}}, :info nil, :end-line 324, :impls #{cljs.core/Cons cljs.core/Eduction cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :test true}, ->LazySeq {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->LazySeq, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([meta fn s __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 4}), :line 2480, :end-line 2480, :max-fixed-arity 4, :fn-var true, :arglists (quote ([meta fn s __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, equiv-map {:protocol-inline nil, :private true, :name cljs.core/equiv-map, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 4888, :end-line 4888, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x y])), :doc "Assumes y is a map. Returns true if x equals y, otherwise returns\n  false.", :test true}, ->Volatile {:protocol-inline nil, :protocols #{cljs.core/IVolatile cljs.core/IDeref}, :name cljs.core/->Volatile, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([state]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Volatile, :variadic false, :max-fixed-arity 1}), :line 3515, :end-line 3515, :max-fixed-arity 1, :fn-var true, :arglists (quote ([state])), :skip-protocol-flag #{cljs.core/IDeref}, :test true}, object-array {:protocol-inline nil, :name cljs.core/object-array, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([size-or-seq] [size init-val-or-seq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1} {:tag array, :variadic false, :max-fixed-arity 2}), :line 2766, :end-line 2766, :max-fixed-arity 2, :fn-var true, :arglists (quote ([size-or-seq] [size init-val-or-seq])), :test true}, Keyword {:num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IPrintWithWriter}, :name cljs.core/Keyword, :file "out/cljs/core.cljs", :end-column 18, :type true, :column 10, :line 2419, :record false, :declared true, :end-line 2419, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IPrintWithWriter}, :test true}, derive {:protocol-inline nil, :name cljs.core/derive, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([tag parent] [h tag parent]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 2} {:tag #{nil cljs.core/IMap clj-nil}, :variadic false, :max-fixed-arity 3}), :line 8692, :end-line 8692, :max-fixed-arity 3, :fn-var true, :arglists (quote ([tag parent] [h tag parent])), :doc "Establishes a parent/child relationship between parent and\n  tag. Parent must be a namespace-qualified symbol or keyword and\n  child can be either a namespace-qualified symbol or keyword or a\n  class. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", :test true}, seq-iter {:protocol-inline nil, :name cljs.core/seq-iter, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/SeqIter, :variadic false, :max-fixed-arity 1}), :line 3039, :end-line 3039, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, IChunkedSeq {:protocol-symbol true, :name cljs.core/IChunkedSeq, :file "out/cljs/core.cljs", :end-column 26, :column 1, :line 388, :protocol-info {:methods {-chunked-first [[coll]], -chunked-rest [[coll]]}}, :info nil, :end-line 388, :impls #{cljs.core/ChunkedSeq cljs.core/ChunkedCons}, :test true}, special-symbol? {:protocol-inline nil, :name cljs.core/special-symbol?, :variadic false, :file "out/cljs/core.cljs", :end-column 32, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 9093, :ret-tag boolean, :end-line 9093, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :test true}, compare-keywords {:protocol-inline nil, :private true, :name cljs.core/compare-keywords, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any number}, :variadic false, :max-fixed-arity 2}), :line 2407, :end-line 2407, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b])), :test true}, ancestors {:protocol-inline nil, :name cljs.core/ancestors, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([tag] [h tag]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj-nil}, :variadic false, :max-fixed-arity 1} {:tag #{nil clj-nil}, :variadic false, :max-fixed-arity 2}), :line 8675, :end-line 8675, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tag] [h tag])), :doc "Returns the immediate and indirect parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", :test true}, subseq {:protocol-inline nil, :name cljs.core/subseq, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([sc test key] [sc start-test start-key end-test end-key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{seq clj cljs.core/LazySeq clj-nil}, :variadic false, :max-fixed-arity 3} {:tag #{cljs.core/LazySeq clj-nil}, :variadic false, :max-fixed-arity 5}), :line 7646, :end-line 7646, :max-fixed-arity 5, :fn-var true, :arglists (quote ([sc test key] [sc start-test start-key end-test end-key])), :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", :test true}, LazyTransformer {:num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/LazyTransformer, :file "out/cljs/core.cljs", :end-column 26, :type true, :column 10, :line 3130, :record false, :declared true, :end-line 3130, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ISequential cljs.core/IWithMeta}, :test true}, gensym {:protocol-inline nil, :name cljs.core/gensym, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([] [prefix-string]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil cljs.core/Symbol}, :variadic false, :max-fixed-arity 0} {:tag #{nil cljs.core/Symbol}, :variadic false, :max-fixed-arity 1}), :line 8383, :end-line 8383, :max-fixed-arity 1, :fn-var true, :arglists (quote ([] [prefix-string])), :doc "Returns a new symbol with a unique name. If a prefix string is\n  supplied, the name is prefix# where # is some unique number. If\n  prefix is not supplied, the prefix is 'G__'.", :test true}, -next {:protocol-inline nil, :protocol cljs.core/INext, :name cljs.core/-next, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 268, :ret-tag clj-or-nil, :end-line 269, :max-fixed-arity 1, :tag clj-or-nil, :fn-var true, :arglists (quote ([coll])), :test true}, ->HashCollisionNode {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->HashCollisionNode, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([edit collision-hash cnt arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/HashCollisionNode, :variadic false, :max-fixed-arity 4}), :line 5870, :end-line 5870, :max-fixed-arity 4, :fn-var true, :arglists (quote ([edit collision-hash cnt arr])), :skip-protocol-flag nil, :test true}, delay? {:protocol-inline nil, :name cljs.core/delay?, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 8412, :ret-tag boolean, :end-line 8412, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "returns true if x is a Delay created with delay", :test true}, create-inode-seq {:protocol-inline nil, :private true, :name cljs.core/create-inode-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([nodes] [nodes i s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/NodeSeq clj-nil}, :variadic false, :max-fixed-arity 1} {:tag #{cljs.core/NodeSeq clj-nil}, :variadic false, :max-fixed-arity 3}), :line 6032, :end-line 6032, :max-fixed-arity 3, :fn-var true, :arglists (quote ([nodes] [nodes i s])), :test true}, flatten {:protocol-inline nil, :name cljs.core/flatten, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 1}), :line 3913, :end-line 3913, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat sequence.\n  (flatten nil) returns nil.", :test true}, -dissoc {:protocol-inline nil, :protocol cljs.core/IMap, :name cljs.core/-dissoc, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([coll k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 279, :ret-tag clj, :end-line 281, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([coll k])), :test true}, doubles {:protocol-inline nil, :name cljs.core/doubles, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1995, :end-line 1995, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, -contains-key? {:protocol-inline nil, :protocol cljs.core/IAssociative, :name cljs.core/-contains-key?, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([coll k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 274, :ret-tag boolean, :end-line 275, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([coll k])), :test true}, remove-watch {:protocol-inline nil, :name cljs.core/remove-watch, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([iref key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 8371, :end-line 8371, :max-fixed-arity 2, :fn-var true, :arglists (quote ([iref key])), :doc "Alpha - subject to change.\n\n  Removes a watch (set by add-watch) from a reference", :test true}, ex-info {:protocol-inline nil, :name cljs.core/ex-info, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([msg map] [msg map cause]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/ExceptionInfo, :variadic false, :max-fixed-arity 2} {:tag cljs.core/ExceptionInfo, :variadic false, :max-fixed-arity 3}), :line 9053, :end-line 9053, :max-fixed-arity 3, :fn-var true, :arglists (quote ([msg map] [msg map cause])), :doc "Alpha - subject to change.\n  Create an instance of ExceptionInfo, an Error type that carries a\n  map of additional data.", :test true}, ->t11983 {:protocol-inline nil, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/->t11983, :variadic false, :file "out/cljs/core.cljs", :method-params ([nil-iter meta11984]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column 3, :factory :positional, :methods ({:tag cljs.core/t11983, :variadic false, :max-fixed-arity 2}), :line 2988, :max-fixed-arity 2, :fn-var true, :arglists (quote ([nil-iter meta11984])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}, :test true}, ifn? {:protocol-inline nil, :name cljs.core/ifn?, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1544, :ret-tag boolean, :end-line 1544, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([f])), :test true}, IAtom {:protocol-symbol true, :name cljs.core/IAtom, :file "out/cljs/core.cljs", :end-column 20, :column 1, :line 399, :protocol-info {:methods {}}, :info nil, :end-line 399, :impls #{cljs.core/Atom}, :test true}, ->PersistentQueue {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/->PersistentQueue, :variadic false, :file "out/cljs/core.cljs", :end-column 26, :method-params ([meta count front rear __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentQueue, :variadic false, :max-fixed-arity 5}), :line 4821, :end-line 4821, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta count front rear __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta}, :test true}, IWatchable {:protocol-symbol true, :name cljs.core/IWatchable, :file "out/cljs/core.cljs", :end-column 25, :column 1, :line 357, :protocol-info {:methods {-notify-watches [[this oldval newval]], -add-watch [[this key f]], -remove-watch [[this key]]}}, :info nil, :end-line 357, :impls #{cljs.core/Atom}, :test true}, ->Stepper {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->Stepper, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([xform iter]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Stepper, :variadic false, :max-fixed-arity 2}), :line 3056, :end-line 3056, :max-fixed-arity 2, :fn-var true, :arglists (quote ([xform iter])), :skip-protocol-flag nil, :test true}, pv-fresh-node {:protocol-inline nil, :private true, :name cljs.core/pv-fresh-node, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([edit]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/VectorNode, :variadic false, :max-fixed-arity 1}), :line 4059, :end-line 4059, :max-fixed-arity 1, :fn-var true, :arglists (quote ([edit])), :test true}, subvec {:protocol-inline nil, :name cljs.core/subvec, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([v start] [v start end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/Subvec, :variadic false, :max-fixed-arity 2} {:tag cljs.core/Subvec, :variadic false, :max-fixed-arity 3}), :line 4582, :end-line 4582, :max-fixed-arity 3, :fn-var true, :arglists (quote ([v start] [v start end])), :doc "Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done.", :test true}, -pop! {:protocol-inline nil, :protocol cljs.core/ITransientVector, :name cljs.core/-pop!, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([tcoll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 375, :ret-tag clj, :end-line 377, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([tcoll])), :test true}, partial {:protocol-inline nil, :name cljs.core/partial, :variadic true, :file "out/cljs/core.cljs", :end-column 15, :method-params ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1} {:tag function, :variadic false, :max-fixed-arity 2} {:tag function, :variadic false, :max-fixed-arity 3} {:tag function, :variadic false, :max-fixed-arity 4} {:tag function, :variadic true, :max-fixed-arity 4}), :line 3301, :end-line 3301, :max-fixed-arity 4, :fn-var true, :arglists (quote ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 & more])), :doc "Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args.", :test true}, chunked-seq? {:protocol-inline nil, :name cljs.core/chunked-seq?, :variadic false, :file "out/cljs/core.cljs", :end-column 29, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1480, :ret-tag boolean, :end-line 1480, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :test true}, replicate {:protocol-inline nil, :name cljs.core/replicate, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([n x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 3801, :end-line 3801, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n x])), :doc "Returns a lazy seq of n xs.", :test true}, PersistentQueue {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/PersistentQueue, :file "out/cljs/core.cljs", :end-column 26, :type true, :column 10, :line 4821, :record false, :end-line 4821, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta}}, min-key {:protocol-inline nil, :name cljs.core/min-key, :variadic true, :file "out/cljs/core.cljs", :end-column 15, :method-params ([k x] [k x y] [k x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 2} {:variadic false, :max-fixed-arity 3} {:tag #{nil any}, :variadic true, :max-fixed-arity 3}), :line 7572, :end-line 7572, :max-fixed-arity 3, :fn-var true, :arglists (quote ([k x] [k x y] [k x y & more])), :doc "Returns the x for which (k x), a number, is least.", :test true}, hash-iset {:protocol-inline nil, :private true, :name cljs.core/hash-iset, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 2176, :end-line 2176, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :test true}, reduced {:protocol-inline nil, :name cljs.core/reduced, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/Reduced, :variadic false, :max-fixed-arity 1}), :line 831, :end-line 831, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Wraps x in a way such that a reduce will terminate with the value x", :test true}, re-matches {:protocol-inline nil, :name cljs.core/re-matches, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([re s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{clj any clj-nil}, :variadic false, :max-fixed-arity 2}), :line 7942, :end-line 7942, :max-fixed-arity 2, :fn-var true, :arglists (quote ([re s])), :doc "Returns the result of (re-find re s) if re fully matches s.", :test true}, array-map {:protocol-inline nil, :name cljs.core/array-map, :variadic true, :file "out/cljs/core.cljs", :end-column 17, :method-params ([keyvals]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic true, :max-fixed-arity 0}), :line 7027, :end-line 7027, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new array map with supplied mappings.", :test true}, ITransientSet {:protocol-symbol true, :name cljs.core/ITransientSet, :file "out/cljs/core.cljs", :end-column 28, :column 1, :line 379, :protocol-info {:methods {-disjoin! [[tcoll v]]}}, :info nil, :end-line 379, :impls #{cljs.core/TransientHashSet}, :test true}, ITER_SYMBOL {:file "out/cljs/core.cljs", :line 154, :column 3, :end-line 154, :end-column 20, :test true, :name cljs.core/ITER_SYMBOL}, unchecked-byte {:protocol-inline nil, :name cljs.core/unchecked-byte, :variadic false, :file "out/cljs/core.cljs", :end-column 30, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1886, :ret-tag number, :end-line 1886, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x])), :test true}, ArrayNode {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/ArrayNode, :file "out/cljs/core.cljs", :end-column 20, :type true, :column 10, :line 5764, :record false, :declared true, :end-line 5764, :skip-protocol-flag nil, :test true}, ->ChunkedSeq {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->ChunkedSeq, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([vec node i off meta __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ChunkedSeq, :variadic false, :max-fixed-arity 6}), :line 4391, :end-line 4391, :max-fixed-arity 6, :fn-var true, :arglists (quote ([vec node i off meta __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, every-pred {:protocol-inline nil, :name cljs.core/every-pred, :variadic true, :file "out/cljs/core.cljs", :end-column 18, :method-params ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 ps]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag function, :variadic false, :max-fixed-arity 2} {:tag function, :variadic false, :max-fixed-arity 3} {:tag function, :variadic true, :max-fixed-arity 3}), :line 3573, :end-line 3573, :max-fixed-arity 3, :fn-var true, :arglists (quote ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps])), :doc "Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates.", :test true}, keys {:protocol-inline nil, :name cljs.core/keys, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([hash-map]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/KeySeq clj-nil}, :variadic false, :max-fixed-arity 1}), :line 7122, :end-line 7122, :max-fixed-arity 1, :fn-var true, :arglists (quote ([hash-map])), :doc "Returns a sequence of the map's keys.", :test true}, missing-protocol {:protocol-inline nil, :name cljs.core/missing-protocol, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([proto obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag js/Error, :variadic false, :max-fixed-arity 2}), :line 137, :end-line 137, :max-fixed-arity 2, :fn-var true, :arglists (quote ([proto obj])), :test true}, PersistentArrayMap {:num-fields 4, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/PersistentArrayMap, :file "out/cljs/core.cljs", :end-column 29, :type true, :column 10, :line 5231, :record false, :end-line 5231, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}}, distinct? {:protocol-inline nil, :name cljs.core/distinct?, :variadic true, :file "out/cljs/core.cljs", :end-column 26, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1} {:tag boolean, :variadic false, :max-fixed-arity 2} {:tag boolean, :variadic true, :max-fixed-arity 2}), :line 1574, :ret-tag boolean, :end-line 1574, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns true if no two of the arguments are =", :test true}, never-equiv {:file "out/cljs/core.cljs", :line 4886, :column 1, :end-line 4886, :end-column 28, :private true, :test true, :name cljs.core/never-equiv}, Stepper {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/Stepper, :file "out/cljs/core.cljs", :end-column 18, :type true, :column 10, :line 3056, :record false, :end-line 3056, :skip-protocol-flag nil}, unchecked-short {:protocol-inline nil, :name cljs.core/unchecked-short, :variadic false, :file "out/cljs/core.cljs", :end-column 31, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1888, :ret-tag number, :end-line 1888, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x])), :test true}, ->Range {:protocol-inline nil, :protocols #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->Range, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([meta start end step __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Range, :variadic false, :max-fixed-arity 5}), :line 7687, :end-line 7687, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta start end step __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, methods {:protocol-inline nil, :name cljs.core/methods, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([multifn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 9012, :end-line 9012, :max-fixed-arity 1, :fn-var true, :arglists (quote ([multifn])), :doc "Given a multimethod, returns a map of dispatch values -> dispatch fns", :test true}, odd? {:protocol-inline nil, :name cljs.core/odd?, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 3254, :ret-tag boolean, :end-line 3254, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :doc "Returns true if n is odd, throws an exception if n is not an integer", :test true}, ->ArrayChunk {:protocol-inline nil, :protocols #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IChunk cljs.core/IReduce}, :name cljs.core/->ArrayChunk, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([arr off end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ArrayChunk, :variadic false, :max-fixed-arity 3}), :line 2565, :end-line 2565, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr off end])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IReduce}, :test true}, lazy-transformer {:protocol-inline nil, :name cljs.core/lazy-transformer, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([stepper]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazyTransformer, :variadic false, :max-fixed-arity 1}), :line 3053, :end-line 3053, :max-fixed-arity 1, :fn-var true, :arglists (quote ([stepper])), :test true}, ci-reduce {:protocol-inline nil, :private true, :name cljs.core/ci-reduce, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([cicoll f] [cicoll f val] [cicoll f val idx]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic false, :max-fixed-arity 3} {:tag #{nil any}, :variadic false, :max-fixed-arity 4}), :line 857, :end-line 857, :max-fixed-arity 4, :fn-var true, :arglists (quote ([cicoll f] [cicoll f val] [cicoll f val idx])), :doc "Accepts any collection which satisfies the ICount and IIndexed protocols and\nreduces them without incurring seq initialization", :test true}, *3 {:file "out/cljs/core.cljs", :line 67, :column 1, :end-line 69, :end-column 6, :doc "bound in a repl thread to the third most recent value printed", :test true, :name cljs.core/*3}, -get-method {:protocol-inline nil, :protocol cljs.core/IMultiFn, :name cljs.core/-get-method, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([mf dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 8799, :end-line 8804, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mf dispatch-val])), :test true}, ->Var {:protocol-inline nil, :protocols #{cljs.core/IMeta cljs.core/IDeref}, :name cljs.core/->Var, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([val sym _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Var, :variadic false, :max-fixed-arity 3}), :line 626, :end-line 626, :max-fixed-arity 3, :fn-var true, :arglists (quote ([val sym _meta])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IDeref}, :test true}, frequencies {:protocol-inline nil, :name cljs.core/frequencies, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 7851, :end-line 7851, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a map from distinct items in coll to the number of times\n  they appear.", :test true}, reduceable? {:protocol-inline nil, :name cljs.core/reduceable?, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1463, :ret-tag boolean, :end-line 1463, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll satisfies IReduce", :test true}, string-hash-cache {:file "out/cljs/core.cljs", :line 498, :column 1, :end-line 498, :end-column 24, :test true, :name cljs.core/string-hash-cache}, rsubseq {:protocol-inline nil, :name cljs.core/rsubseq, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([sc test key] [sc start-test start-key end-test end-key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{seq clj cljs.core/LazySeq clj-nil}, :variadic false, :max-fixed-arity 3} {:tag #{cljs.core/LazySeq clj-nil}, :variadic false, :max-fixed-arity 5}), :line 7661, :end-line 7661, :max-fixed-arity 5, :fn-var true, :arglists (quote ([sc test key] [sc start-test start-key end-test end-key])), :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a reverse seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", :test true}, inc {:protocol-inline nil, :name cljs.core/inc, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 821, :end-line 821, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a number one greater than num.", :test true}, type->str {:protocol-inline nil, :name cljs.core/type->str, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([ty]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 146, :end-line 146, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ty])), :test true}, obj-clone {:protocol-inline nil, :private true, :name cljs.core/obj-clone, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([obj ks]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag object, :variadic false, :max-fixed-arity 2}), :line 4938, :end-line 4938, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj ks])), :test true}, get-method {:protocol-inline nil, :name cljs.core/get-method, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([multifn dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 9016, :end-line 9016, :max-fixed-arity 2, :fn-var true, :arglists (quote ([multifn dispatch-val])), :doc "Given a multimethod and a dispatch value, returns the dispatch fn\n  that would apply to that value, or nil if none apply and no default", :test true}, vector-index-out-of-bounds {:protocol-inline nil, :private true, :name cljs.core/vector-index-out-of-bounds, :variadic false, :file "out/cljs/core.cljs", :end-column 35, :method-params ([i cnt]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag ignore, :variadic false, :max-fixed-arity 2}), :line 4103, :end-line 4103, :max-fixed-arity 2, :fn-var true, :arglists (quote ([i cnt])), :test true}, es6-entries-iterator {:protocol-inline nil, :name cljs.core/es6-entries-iterator, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/ES6EntriesIterator, :variadic false, :max-fixed-arity 1}), :line 5068, :end-line 5068, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, bit-clear {:protocol-inline nil, :name cljs.core/bit-clear, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2036, :end-line 2036, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Clear bit at index n", :test true}, Range {:num-fields 5, :protocols #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/Range, :file "out/cljs/core.cljs", :end-column 16, :type true, :column 10, :line 7687, :record false, :end-line 7687, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, filter {:protocol-inline nil, :name cljs.core/filter, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([pred] [pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 3861, :end-line 3861, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :test true}, ->PersistentTreeMapSeq {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->PersistentTreeMapSeq, :variadic false, :file "out/cljs/core.cljs", :end-column 31, :method-params ([meta stack ascending? cnt __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentTreeMapSeq, :variadic false, :max-fixed-arity 5}), :line 6355, :end-line 6355, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta stack ascending? cnt __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, create-array-node-seq {:protocol-inline nil, :private true, :name cljs.core/create-array-node-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 30, :method-params ([nodes] [meta nodes i s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/ArrayNodeSeq clj-nil}, :variadic false, :max-fixed-arity 1} {:tag #{cljs.core/ArrayNodeSeq clj-nil}, :variadic false, :max-fixed-arity 4}), :line 6088, :end-line 6088, :max-fixed-arity 4, :fn-var true, :arglists (quote ([nodes] [meta nodes i s])), :test true}, -assoc-n! {:protocol-inline nil, :protocol cljs.core/ITransientVector, :name cljs.core/-assoc-n!, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([tcoll n val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 375, :ret-tag clj, :end-line 376, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([tcoll n val])), :test true}, IWithMeta {:protocol-symbol true, :name cljs.core/IWithMeta, :file "out/cljs/core.cljs", :end-column 24, :column 1, :line 306, :protocol-info {:methods {-with-meta [[o meta]]}}, :info nil, :end-line 306, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/t11986 cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/t11983 cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/MetaFn cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :test true}, list {:protocol-inline nil, :name cljs.core/list, :variadic true, :file "out/cljs/core.cljs", :end-column 12, :method-params ([xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag not-native, :variadic true, :max-fixed-arity 0}), :line 2329, :end-line 2329, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& xs])), :test true}, + {:protocol-inline nil, :name cljs.core/+, :variadic true, :file "out/cljs/core.cljs", :end-column 17, :method-params ([] [x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 0} {:variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 1775, :ret-tag number, :end-line 1775, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the sum of nums. (+) returns 0.", :test true}, IndexedSeqIterator {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/IndexedSeqIterator, :file "out/cljs/core.cljs", :end-column 29, :type true, :column 10, :line 931, :record false, :end-line 931, :skip-protocol-flag nil}, split-with {:protocol-inline nil, :name cljs.core/split-with, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/IVector, :variadic false, :max-fixed-arity 2}), :line 7805, :end-line 7805, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns a vector of [(take-while pred coll) (drop-while pred coll)]", :test true}, ->VectorNode {:protocol-inline nil, :protocols #{}, :name cljs.core/->VectorNode, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([edit arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/VectorNode, :variadic false, :max-fixed-arity 2}), :line 4057, :end-line 4057, :max-fixed-arity 2, :fn-var true, :arglists (quote ([edit arr])), :skip-protocol-flag nil, :test true}, aset {:protocol-inline nil, :name cljs.core/aset, :variadic true, :file "out/cljs/core.cljs", :end-column 12, :method-params ([array i val] [array idx idx2 idxv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 3} {:tag any, :variadic true, :max-fixed-arity 3}), :line 188, :end-line 188, :max-fixed-arity 3, :fn-var true, :arglists (quote ([array i val] [array idx idx2 & idxv])), :doc "Sets the value at the index.", :test true}, int-rotate-left {:protocol-inline nil, :name cljs.core/int-rotate-left, :variadic false, :file "out/cljs/core.cljs", :end-column 31, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 433, :ret-tag number, :end-line 433, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x n])), :test true}, keyword {:protocol-inline nil, :name cljs.core/keyword, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([name] [ns name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil cljs.core/Keyword clj-nil}, :variadic false, :max-fixed-arity 1} {:tag cljs.core/Keyword, :variadic false, :max-fixed-arity 2}), :line 2465, :end-line 2465, :max-fixed-arity 2, :fn-var true, :arglists (quote ([name] [ns name])), :doc "Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically.", :test true}, ->Cons {:protocol-inline nil, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->Cons, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([meta first rest __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Cons, :variadic false, :max-fixed-arity 4}), :line 2344, :end-line 2344, :max-fixed-arity 4, :fn-var true, :arglists (quote ([meta first rest __hash])), :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, create-tree-map-seq {:protocol-inline nil, :private true, :name cljs.core/create-tree-map-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([tree ascending? cnt]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/PersistentTreeMapSeq, :variadic false, :max-fixed-arity 3}), :line 6408, :end-line 6408, :max-fixed-arity 3, :fn-var true, :arglists (quote ([tree ascending? cnt])), :test true}, ICollection {:protocol-symbol true, :name cljs.core/ICollection, :file "out/cljs/core.cljs", :end-column 26, :column 1, :line 253, :protocol-info {:methods {-conj [[coll o]]}}, :info nil, :end-line 253, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :test true}, multi-stepper {:protocol-inline nil, :name cljs.core/multi-stepper, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([xform iters] [xform iters nexts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:variadic false, :max-fixed-arity 3}), :line 3110, :end-line 3110, :max-fixed-arity 3, :fn-var true, :arglists (quote ([xform iters] [xform iters nexts])), :test true}, chars {:protocol-inline nil, :name cljs.core/chars, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1991, :end-line 1991, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, str {:protocol-inline nil, :name cljs.core/str, :variadic true, :file "out/cljs/core.cljs", :end-column 11, :method-params ([] [x] [x ys]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag string, :variadic false, :max-fixed-arity 0} {:tag #{any string}, :variadic false, :max-fixed-arity 1} {:tag any, :variadic true, :max-fixed-arity 1}), :line 2119, :end-line 2119, :max-fixed-arity 1, :fn-var true, :arglists (quote ([] [x] [x & ys])), :doc "With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args.", :test true}, next {:protocol-inline nil, :name cljs.core/next, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{seq clj-or-nil clj-nil}, :variadic false, :max-fixed-arity 1}), :line 692, :ret-tag seq, :end-line 692, :max-fixed-arity 1, :tag seq, :fn-var true, :arglists (quote ([coll])), :doc "Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil", :test true}, ASeq {:protocol-symbol true, :name cljs.core/ASeq, :file "out/cljs/core.cljs", :end-column 19, :column 1, :line 262, :protocol-info {:methods {}}, :info nil, :end-line 262, :impls #{cljs.core/Cons cljs.core/IndexedSeq cljs.core/List cljs.core/ChunkedSeq cljs.core/ChunkedCons}, :test true}, pr-seq-writer {:protocol-inline nil, :name cljs.core/pr-seq-writer, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([objs writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 3}), :line 8107, :end-line 8107, :max-fixed-arity 3, :fn-var true, :arglists (quote ([objs writer opts])), :test true}, SeqIter {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/SeqIter, :file "out/cljs/core.cljs", :end-column 18, :type true, :column 10, :line 3021, :record false, :end-line 3021, :skip-protocol-flag nil}, IFn {:protocol-symbol true, :name cljs.core/IFn, :file "out/cljs/core.cljs", :end-column 18, :column 1, :line 219, :protocol-info {:methods {-invoke [[this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]]}}, :info nil, :end-line 219, :impls #{cljs.core/PersistentHashMap cljs.core/MultiFn cljs.core/ObjMap cljs.core/TransientVector cljs.core/PersistentArrayMap cljs.core/Keyword cljs.core/BlackNode cljs.core/Subvec cljs.core/PersistentVector cljs.core/TransientHashSet cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet cljs.core/Symbol cljs.core/MetaFn cljs.core/RedNode}, :test true}, regexp? {:protocol-inline nil, :name cljs.core/regexp?, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 7939, :end-line 7939, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o])), :test true}, hash-map {:protocol-inline nil, :name cljs.core/hash-map, :variadic true, :file "out/cljs/core.cljs", :end-column 16, :method-params ([keyvals]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic true, :max-fixed-arity 0}), :line 7018, :end-line 7018, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new hash map with supplied mappings.", :test true}, underive {:protocol-inline nil, :name cljs.core/underive, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([tag parent] [h tag parent]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 8726, :end-line 8726, :max-fixed-arity 3, :fn-var true, :arglists (quote ([tag parent] [h tag parent])), :doc "Removes a parent/child relationship between parent and\n  tag. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", :test true}, t11986 {:num-fields 2, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/t11986, :file "out/cljs/core.cljs", :type true, :anonymous true, :column 3, :line 2988, :record false, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, array-copy {:protocol-inline nil, :private true, :name cljs.core/array-copy, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([from i to j len]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 5}), :line 1498, :end-line 1498, :max-fixed-arity 5, :fn-var true, :arglists (quote ([from i to j len])), :test true}, obj-map-compare-keys {:protocol-inline nil, :private true, :name cljs.core/obj-map-compare-keys, :variadic false, :file "out/cljs/core.cljs", :end-column 29, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 4916, :end-line 4916, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b])), :test true}, -reset! {:protocol-inline nil, :protocol cljs.core/IReset, :name cljs.core/-reset!, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([o new-value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 401, :end-line 402, :max-fixed-arity 2, :fn-var true, :arglists (quote ([o new-value])), :test true}, -rest {:protocol-inline nil, :protocol cljs.core/ISeq, :name cljs.core/-rest, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 264, :ret-tag clj, :end-line 266, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([coll])), :test true}, nil-iter {:protocol-inline nil, :name cljs.core/nil-iter, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/t11986, :variadic false, :max-fixed-arity 0}), :line 2987, :end-line 2987, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :test true}, pr-writer {:protocol-inline nil, :private true, :name cljs.core/pr-writer, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([obj writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 3}), :line 8036, :end-line 8036, :max-fixed-arity 3, :fn-var true, :arglists (quote ([obj writer opts])), :doc "Prefer this to pr-seq, because it makes the printing function\n   configurable, allowing efficient implementations such as appending\n   to a StringBuffer.", :test true}, false? {:protocol-inline nil, :name cljs.core/false?, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1518, :ret-tag boolean, :end-line 1518, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is the value false, false otherwise.", :test true}, RangedIterator {:num-fields 6, :protocols #{cljs.core/Object}, :name cljs.core/RangedIterator, :file "out/cljs/core.cljs", :end-column 25, :type true, :column 10, :line 4154, :record false, :end-line 4154, :skip-protocol-flag nil}, *print-readably* {:file "out/cljs/core.cljs", :line 34, :column 1, :end-line 34, :end-column 33, :dynamic true, :test true, :name cljs.core/*print-readably*}, ints {:protocol-inline nil, :name cljs.core/ints, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1993, :end-line 1993, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, some-fn {:protocol-inline nil, :name cljs.core/some-fn, :variadic true, :file "out/cljs/core.cljs", :end-column 15, :method-params ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 ps]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag function, :variadic false, :max-fixed-arity 2} {:tag function, :variadic false, :max-fixed-arity 3} {:tag function, :variadic true, :max-fixed-arity 3}), :line 3612, :end-line 3612, :max-fixed-arity 3, :fn-var true, :arglists (quote ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps])), :doc "Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates.", :test true}, *flush-on-newline* {:file "out/cljs/core.cljs", :line 32, :column 1, :end-line 32, :end-column 35, :dynamic true, :test true, :name cljs.core/*flush-on-newline*}, to-array {:protocol-inline nil, :name cljs.core/to-array, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1}), :line 2685, :end-line 2685, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Naive impl of to-array as a start.", :test true}, build-subvec {:protocol-inline nil, :private true, :name cljs.core/build-subvec, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([meta v start end __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/Subvec, :variadic false, :max-fixed-arity 5}), :line 4571, :end-line 4571, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta v start end __hash])), :test true}, list? {:protocol-inline nil, :name cljs.core/list?, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 2401, :ret-tag boolean, :end-line 2401, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :test true}, tree-map-remove {:protocol-inline nil, :private true, :name cljs.core/tree-map-remove, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([comp tree k found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil cljs.core/BlackNode clj-nil cljs.core/RedNode}, :variadic false, :max-fixed-arity 4}), :line 6837, :end-line 6837, :max-fixed-arity 4, :fn-var true, :arglists (quote ([comp tree k found])), :test true}, HashCollisionNode {:num-fields 4, :protocols #{cljs.core/Object}, :name cljs.core/HashCollisionNode, :file "out/cljs/core.cljs", :end-column 28, :type true, :column 10, :line 5870, :record false, :end-line 5870, :skip-protocol-flag nil}, array? {:protocol-inline nil, :name cljs.core/array?, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 90, :ret-tag boolean, :end-line 90, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :test true}, prefers* {:protocol-inline nil, :private true, :name cljs.core/prefers*, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([x y prefer-table]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{boolean clj-nil}, :variadic false, :max-fixed-arity 3}), :line 8752, :end-line 8752, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x y prefer-table])), :test true}, clone {:protocol-inline nil, :name cljs.core/clone, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 639, :end-line 639, :max-fixed-arity 1, :fn-var true, :arglists (quote ([value])), :test true}, scan-array {:protocol-inline nil, :private true, :name cljs.core/scan-array, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([incr k array]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{number clj-nil}, :variadic false, :max-fixed-arity 3}), :line 4902, :end-line 4902, :max-fixed-arity 3, :fn-var true, :arglists (quote ([incr k array])), :test true}, bit-not {:protocol-inline nil, :name cljs.core/bit-not, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 2046, :end-line 2046, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Bitwise complement", :test true}, quote-string {:protocol-inline nil, :private true, :name cljs.core/quote-string, :variadic false, :file "out/cljs/core.cljs", :end-column 30, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 8027, :end-line 8027, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :test true}, byte {:protocol-inline nil, :name cljs.core/byte, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1872, :ret-tag number, :end-line 1872, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x])), :test true}, max {:protocol-inline nil, :name cljs.core/max, :variadic true, :file "out/cljs/core.cljs", :end-column 19, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1} {:variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 1858, :ret-tag number, :end-line 1858, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns the greatest of the nums.", :test true}, IComparable {:protocol-symbol true, :name cljs.core/IComparable, :file "out/cljs/core.cljs", :end-column 26, :column 1, :line 382, :protocol-info {:methods {-compare [[x y]]}}, :info nil, :end-line 382, :impls #{cljs.core/Keyword cljs.core/Subvec cljs.core/PersistentVector cljs.core/Symbol}, :test true}, == {:protocol-inline nil, :name cljs.core/==, :variadic true, :file "out/cljs/core.cljs", :end-column 19, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1} {:tag boolean, :variadic false, :max-fixed-arity 2} {:tag boolean, :variadic true, :max-fixed-arity 2}), :line 2083, :ret-tag boolean, :end-line 2083, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums all have the equivalent\n  value, otherwise false. Behavior on non nums is\n  undefined.", :test true}, parents {:protocol-inline nil, :name cljs.core/parents, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([tag] [h tag]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj-nil}, :variadic false, :max-fixed-arity 1} {:tag #{nil clj-nil}, :variadic false, :max-fixed-arity 2}), :line 8667, :end-line 8667, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tag] [h tag])), :doc "Returns the immediate parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", :test true}, count {:protocol-inline nil, :name cljs.core/count, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 1144, :end-line 1144, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Maps", :test true}, -disjoin! {:protocol-inline nil, :protocol cljs.core/ITransientSet, :name cljs.core/-disjoin!, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([tcoll v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 379, :ret-tag clj, :end-line 380, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([tcoll v])), :test true}, *loaded-libs* {:file "out/cljs/core.cljs", :line 40, :column 1, :end-line 40, :end-column 34, :dynamic true, :test true, :name cljs.core/*loaded-libs*}, ->TransientHashMap {:protocol-inline nil, :protocols #{cljs.core/ITransientMap cljs.core/Object cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/->TransientHashMap, :variadic false, :file "out/cljs/core.cljs", :end-column 27, :method-params ([edit root count has-nil? nil-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/TransientHashMap, :variadic false, :max-fixed-arity 5}), :line 6243, :end-line 6243, :max-fixed-arity 5, :fn-var true, :arglists (quote ([edit root count has-nil? nil-val])), :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :test true}, ArrayChunk {:num-fields 3, :protocols #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IChunk cljs.core/IReduce}, :name cljs.core/ArrayChunk, :file "out/cljs/core.cljs", :end-column 21, :type true, :column 10, :line 2565, :record false, :declared true, :end-line 2565, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IReduce}, :test true}, sorted-map-by {:protocol-inline nil, :name cljs.core/sorted-map-by, :variadic true, :file "out/cljs/core.cljs", :end-column 21, :method-params ([comparator keyvals]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/PersistentTreeMap, :variadic true, :max-fixed-arity 1}), :line 7055, :end-line 7055, :max-fixed-arity 1, :fn-var true, :arglists (quote ([comparator & keyvals])), :doc "keyval => key val\n  Returns a new sorted map with supplied mappings, using the supplied comparator.", :test true}, apply {:protocol-inline nil, :name cljs.core/apply, :variadic true, :file "out/cljs/core.cljs", :end-column 13, :method-params ([f args] [f x args] [f x y args] [f x y z args] [f a b c d args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:tag any, :variadic false, :max-fixed-arity 3} {:tag any, :variadic false, :max-fixed-arity 4} {:tag any, :variadic false, :max-fixed-arity 5} {:tag any, :variadic true, :max-fixed-arity 5}), :line 2911, :end-line 2911, :max-fixed-arity 5, :fn-var true, :arglists (quote ([f args] [f x args] [f x y args] [f x y z args] [f a b c d & args])), :doc "Applies fn f to the argument list formed by prepending intervening arguments to args.\n  First cut.  Not lazy.  Needs to use emitted toApply.", :test true}, get-global-hierarchy {:protocol-inline nil, :private true, :name cljs.core/get-global-hierarchy, :variadic false, :file "out/cljs/core.cljs", :end-column 29, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 0}), :line 8639, :end-line 8639, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :test true}, add-to-string-hash-cache {:protocol-inline nil, :name cljs.core/add-to-string-hash-cache, :variadic false, :file "out/cljs/core.cljs", :end-column 32, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 513, :end-line 513, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k])), :test true}, clj->js {:protocol-inline nil, :name cljs.core/clj->js, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil object any array string clj-nil}, :variadic false, :max-fixed-arity 1}), :line 8519, :end-line 8519, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Recursively transforms ClojureScript values to JavaScript.\nsets/vectors/lists become Arrays, Keywords and Symbol become Strings,\nMaps become Objects. Arbitrary keys are encoded to by key->js.", :test true}, TransientArrayMap {:num-fields 3, :protocols #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/TransientArrayMap, :file "out/cljs/core.cljs", :end-column 28, :type true, :column 10, :line 5411, :record false, :declared true, :end-line 5411, :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :test true}, ->TransientVector {:protocol-inline nil, :protocols #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/->TransientVector, :variadic false, :file "out/cljs/core.cljs", :end-column 26, :method-params ([cnt shift root tail]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/TransientVector, :variadic false, :max-fixed-arity 4}), :line 4648, :end-line 4648, :max-fixed-arity 4, :fn-var true, :arglists (quote ([cnt shift root tail])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}, :test true}, IChunkedNext {:protocol-symbol true, :name cljs.core/IChunkedNext, :file "out/cljs/core.cljs", :end-column 27, :column 1, :line 392, :protocol-info {:methods {-chunked-next [[coll]]}}, :info nil, :end-line 392, :impls #{cljs.core/ChunkedSeq cljs.core/ChunkedCons}, :test true}, interpose {:protocol-inline nil, :name cljs.core/interpose, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([sep coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 3831, :end-line 3831, :max-fixed-arity 2, :fn-var true, :arglists (quote ([sep coll])), :doc "Returns a lazy seq of the elements of coll separated by sep", :test true}, ->BlackNode {:protocol-inline nil, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->BlackNode, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([key val left right __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/BlackNode, :variadic false, :max-fixed-arity 5}), :line 6514, :end-line 6514, :max-fixed-arity 5, :fn-var true, :arglists (quote ([key val left right __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :test true}, deref {:file "out/cljs/core.cljs", :line 5492, :column 1, :end-line 5492, :end-column 79, :declared true, :test true, :name cljs.core/deref}, pv-aget {:protocol-inline nil, :private true, :name cljs.core/pv-aget, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([node idx]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 4062, :end-line 4062, :max-fixed-arity 2, :fn-var true, :arglists (quote ([node idx])), :test true}, assoc {:protocol-inline nil, :name cljs.core/assoc, :variadic true, :file "out/cljs/core.cljs", :end-column 13, :method-params ([coll k v] [coll k v kvs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 3} {:tag clj, :variadic true, :max-fixed-arity 3}), :line 1301, :end-line 1301, :max-fixed-arity 3, :fn-var true, :arglists (quote ([coll k v] [coll k v & kvs])), :doc "assoc[iate]. When applied to a map, returns a new map of the\n   same (hashed/sorted) type, that contains the mapping of key(s) to\n   val(s). When applied to a vector, returns a new vector that\n   contains val at index.", :test true}, transient {:protocol-inline nil, :name cljs.core/transient, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 2840, :end-line 2840, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new, transient version of the collection, in constant time.", :test true}, -disjoin {:protocol-inline nil, :protocol cljs.core/ISet, :name cljs.core/-disjoin, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([coll v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 287, :ret-tag clj, :end-line 288, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([coll v])), :test true}, chunk-cons {:protocol-inline nil, :name cljs.core/chunk-cons, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([chunk rest]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil cljs.core/ChunkedCons}, :variadic false, :max-fixed-arity 2}), :line 2661, :end-line 2661, :max-fixed-arity 2, :fn-var true, :arglists (quote ([chunk rest])), :test true}, ArrayIter {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/ArrayIter, :file "out/cljs/core.cljs", :end-column 20, :type true, :column 10, :line 3006, :record false, :end-line 3006, :skip-protocol-flag nil}, comparator {:protocol-inline nil, :name cljs.core/comparator, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([pred]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1}), :line 9087, :end-line 9087, :max-fixed-arity 1, :fn-var true, :arglists (quote ([pred])), :doc "Returns an JavaScript compatible comparator based upon pred.", :test true}, sorted-map {:protocol-inline nil, :name cljs.core/sorted-map, :variadic true, :file "out/cljs/core.cljs", :end-column 18, :method-params ([keyvals]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic true, :max-fixed-arity 0}), :line 7046, :end-line 7046, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new sorted map with supplied mappings.", :test true}, drop-while {:protocol-inline nil, :name cljs.core/drop-while, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([pred] [pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 3760, :end-line 3760, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of the items in coll starting from the\n  first item for which (pred item) returns logical false.  Returns a\n  stateful transducer when no collection is provided.", :test true}, IWriter {:protocol-symbol true, :name cljs.core/IWriter, :file "out/cljs/core.cljs", :end-column 22, :column 1, :line 342, :protocol-info {:methods {-write [[writer s]], -flush [[writer]]}}, :info nil, :end-line 342, :impls #{cljs.core/StringBufferWriter}, :test true}, KeySeq {:num-fields 2, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/KeySeq, :file "out/cljs/core.cljs", :end-column 17, :type true, :column 10, :line 7065, :record false, :end-line 7065, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, realized? {:protocol-inline nil, :name cljs.core/realized?, :variadic false, :file "out/cljs/core.cljs", :end-column 26, :method-params ([d]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 8423, :ret-tag boolean, :end-line 8423, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([d])), :doc "Returns true if a value has been produced for a promise, delay, future or lazy sequence.", :test true}, array-map-index-of-keyword? {:protocol-inline nil, :private true, :name cljs.core/array-map-index-of-keyword?, :variadic false, :file "out/cljs/core.cljs", :end-column 36, :method-params ([arr m k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 3}), :line 5094, :end-line 5094, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr m k])), :test true}, *print-fn* {:protocol-inline nil, :name cljs.core/*print-fn*, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([_]), :protocol-impl nil, :arglists-meta (), :column 1, :methods ({:tag ignore, :variadic false, :max-fixed-arity 1}), :dynamic true, :line 20, :end-line 24, :max-fixed-arity 1, :fn-var true, :arglists nil, :doc "Each runtime environment provides a different way to print output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed.", :test true}, compare {:protocol-inline nil, :name cljs.core/compare, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any number}, :variadic false, :max-fixed-arity 2}), :line 1592, :ret-tag number, :end-line 1592, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x y])), :doc "Comparator. Returns a negative number, zero, or a positive number\n  when x is logically 'less than', 'equal to', or 'greater than'\n  y. Uses IComparable if available and google.array.defaultCompare for objects\n of the same type and special-cases nil to be less than any other object.", :test true}, complement {:protocol-inline nil, :name cljs.core/complement, :variadic false, :file "out/cljs/core.cljs", :end-column 27, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1}), :line 3258, :ret-tag boolean, :end-line 3258, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([f])), :doc "Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value.", :test true}, lookup-sentinel {:file "out/cljs/core.cljs", :line 1516, :column 1, :end-line 1516, :end-column 32, :private true, :test true, :name cljs.core/lookup-sentinel}, -assoc! {:protocol-inline nil, :protocol cljs.core/ITransientAssociative, :name cljs.core/-assoc!, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([tcoll key val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 369, :ret-tag clj, :end-line 370, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([tcoll key val])), :test true}, *print-dup* {:file "out/cljs/core.cljs", :line 36, :column 1, :end-line 36, :end-column 28, :dynamic true, :test true, :name cljs.core/*print-dup*}, string-iter {:protocol-inline nil, :name cljs.core/string-iter, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/StringIter, :variadic false, :max-fixed-arity 1}), :line 3003, :end-line 3003, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, -key->js {:protocol-inline nil, :protocol cljs.core/IEncodeJS, :name cljs.core/-key->js, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 8502, :end-line 8504, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, IDeref {:protocol-symbol true, :name cljs.core/IDeref, :file "out/cljs/core.cljs", :end-column 21, :column 1, :line 297, :protocol-info {:methods {-deref [[o]]}}, :info nil, :end-line 297, :impls #{cljs.core/Reduced cljs.core/Volatile cljs.core/Delay cljs.core/Var cljs.core/Atom}, :test true}, sequence {:protocol-inline nil, :name cljs.core/sequence, :variadic true, :file "out/cljs/core.cljs", :end-column 16, :method-params ([coll] [xform coll] [xform coll colls]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil seq cljs.core/IList}, :variadic false, :max-fixed-arity 1} {:tag any, :variadic false, :max-fixed-arity 2} {:tag any, :variadic true, :max-fixed-arity 2}), :line 3202, :end-line 3202, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll] [xform coll] [xform coll & colls])), :doc "Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\n  transducer is supplied, returns a lazy sequence of applications of\n  the transform to the items in coll(s), i.e. to the set of first\n  items of each coll, followed by the set of second\n  items in each coll, until any one of the colls is exhausted.  Any\n  remaining items in other colls are ignored. The transform should accept\n  number-of-colls arguments", :test true}, constantly {:protocol-inline nil, :name cljs.core/constantly, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1}), :line 3268, :end-line 3268, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a function that takes any number of arguments and returns x.", :test true}, ->RangedIterator {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->RangedIterator, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([i base arr v start end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/RangedIterator, :variadic false, :max-fixed-arity 6}), :line 4154, :end-line 4154, :max-fixed-arity 6, :fn-var true, :arglists (quote ([i base arr v start end])), :skip-protocol-flag nil, :test true}, chunked-seq {:protocol-inline nil, :name cljs.core/chunked-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([vec i off] [vec node i off] [vec node i off meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/ChunkedSeq, :variadic false, :max-fixed-arity 3} {:tag cljs.core/ChunkedSeq, :variadic false, :max-fixed-arity 4} {:tag cljs.core/ChunkedSeq, :variadic false, :max-fixed-arity 5}), :line 4467, :end-line 4467, :max-fixed-arity 5, :fn-var true, :arglists (quote ([vec i off] [vec node i off] [vec node i off meta])), :test true}, ISorted {:protocol-symbol true, :name cljs.core/ISorted, :file "out/cljs/core.cljs", :end-column 22, :column 1, :line 336, :protocol-info {:methods {-sorted-seq [[coll ascending?]], -sorted-seq-from [[coll k ascending?]], -entry-key [[coll entry]], -comparator [[coll]]}}, :info nil, :end-line 336, :impls #{cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet}, :test true}, make-array {:protocol-inline nil, :name cljs.core/make-array, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([size] [type size]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1} {:tag array, :variadic false, :max-fixed-arity 2}), :line 158, :ret-tag array, :end-line 158, :max-fixed-arity 2, :tag array, :fn-var true, :arglists (quote ([size] [type size])), :test true}, shorts {:protocol-inline nil, :name cljs.core/shorts, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1992, :end-line 1992, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, *unchecked-if* {:file "out/cljs/core.cljs", :line 18, :column 1, :end-line 18, :end-column 21, :test true, :name cljs.core/*unchecked-if*}, ->RSeq {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->RSeq, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([ci i meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/RSeq, :variadic false, :max-fixed-arity 3}), :line 1025, :end-line 1025, :max-fixed-arity 3, :fn-var true, :arglists (quote ([ci i meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, enable-console-print! {:protocol-inline nil, :name cljs.core/enable-console-print!, :variadic false, :file "out/cljs/core.cljs", :end-column 29, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 0}), :line 51, :end-line 51, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Set *print-fn* to console.log", :test true}, -flush {:protocol-inline nil, :protocol cljs.core/IWriter, :name cljs.core/-flush, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([writer]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 342, :end-line 344, :max-fixed-arity 1, :fn-var true, :arglists (quote ([writer])), :test true}, completing {:protocol-inline nil, :name cljs.core/completing, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([f] [f cf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag function, :variadic false, :max-fixed-arity 2}), :line 1749, :end-line 1749, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f] [f cf])), :test true}, unchecked-negate-int {:protocol-inline nil, :name cljs.core/unchecked-negate-int, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 1942, :end-line 1942, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, ->PersistentVector {:protocol-inline nil, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->PersistentVector, :variadic false, :file "out/cljs/core.cljs", :end-column 27, :method-params ([meta cnt shift root tail __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentVector, :variadic false, :max-fixed-arity 6}), :line 4176, :end-line 4176, :max-fixed-arity 6, :fn-var true, :arglists (quote ([meta cnt shift root tail __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :test true}, equiv-sequential {:protocol-inline nil, :private true, :name cljs.core/equiv-sequential, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 2141, :end-line 2141, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x y])), :doc "Assumes x is sequential. Returns true if x equals y, otherwise\n  returns false.", :test true}, hash-unordered-coll {:protocol-inline nil, :name cljs.core/hash-unordered-coll, :variadic false, :file "out/cljs/core.cljs", :end-column 35, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 775, :ret-tag number, :end-line 775, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([coll])), :doc "Returns the hash code, consistent with =, for an external unordered\n   collection implementing Iterable. For maps, the iterator should\n   return map entries whose hash is computed as\n     (hash-ordered-coll [k v]).\n   See http://clojure.org/data_structures#hash for full algorithms.", :test true}, repeat {:protocol-inline nil, :name cljs.core/repeat, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([x] [n x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 3796, :end-line 3796, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x] [n x])), :doc "Returns a lazy (infinite!, or length n if supplied) sequence of xs.", :test true}, unchecked-inc {:protocol-inline nil, :name cljs.core/unchecked-inc, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 1919, :end-line 1919, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, nthnext {:protocol-inline nil, :name cljs.core/nthnext, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([coll n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag seq, :variadic false, :max-fixed-arity 2}), :line 2109, :end-line 2109, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll n])), :doc "Returns the nth next of coll, (seq coll) when n is 0.", :test true}, preserving-reduced {:protocol-inline nil, :private true, :name cljs.core/preserving-reduced, :variadic false, :file "out/cljs/core.cljs", :end-column 27, :method-params ([rf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1}), :line 8428, :end-line 8428, :max-fixed-arity 1, :fn-var true, :arglists (quote ([rf])), :test true}, get-validator {:protocol-inline nil, :name cljs.core/get-validator, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([iref]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 3510, :end-line 3510, :max-fixed-arity 1, :fn-var true, :arglists (quote ([iref])), :doc "Gets the validator-fn for a var/ref/agent/atom.", :test true}, StringIter {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/StringIter, :file "out/cljs/core.cljs", :end-column 21, :type true, :column 10, :line 2994, :record false, :end-line 2994, :skip-protocol-flag nil}, number? {:protocol-inline nil, :name cljs.core/number?, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 93, :ret-tag boolean, :end-line 93, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :test true}, -conj! {:protocol-inline nil, :protocol cljs.core/ITransientCollection, :name cljs.core/-conj!, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([tcoll val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 365, :ret-tag clj, :end-line 366, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([tcoll val])), :test true}, ->PersistentArrayMapSeq {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->PersistentArrayMapSeq, :variadic false, :file "out/cljs/core.cljs", :end-column 32, :method-params ([arr i _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentArrayMapSeq, :variadic false, :max-fixed-arity 3}), :line 5161, :end-line 5161, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr i _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, chunk-next {:protocol-inline nil, :name cljs.core/chunk-next, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{seq any}, :variadic false, :max-fixed-arity 1}), :line 2678, :end-line 2678, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :test true}, ArrayList {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/ArrayList, :file "out/cljs/core.cljs", :end-column 20, :type true, :column 10, :line 7579, :record false, :end-line 7579, :skip-protocol-flag nil}, print-str {:protocol-inline nil, :name cljs.core/print-str, :variadic true, :file "out/cljs/core.cljs", :end-column 17, :method-params ([objs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil string}, :variadic true, :max-fixed-arity 0}), :line 8173, :end-line 8173, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& objs])), :doc "print to a string, returning it", :test true}, not-any? {:protocol-inline nil, :name cljs.core/not-any?, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 3243, :ret-tag boolean, :end-line 3243, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns false if (pred x) is logical true for any x in coll,\n  else true.", :test true}, into-array {:protocol-inline nil, :name cljs.core/into-array, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([aseq] [type aseq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1} {:tag any, :variadic false, :max-fixed-arity 2}), :line 202, :ret-tag array, :end-line 202, :max-fixed-arity 2, :tag array, :fn-var true, :arglists (quote ([aseq] [type aseq])), :test true}, -hash {:protocol-inline nil, :protocol cljs.core/IHash, :name cljs.core/-hash, :variadic false, :file "out/cljs/core.cljs", :end-column 10, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 318, :end-line 319, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o])), :test true}, -dissoc! {:protocol-inline nil, :protocol cljs.core/ITransientMap, :name cljs.core/-dissoc!, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([tcoll key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 372, :ret-tag clj, :end-line 373, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([tcoll key])), :test true}, ->Reduced {:protocol-inline nil, :protocols #{cljs.core/IDeref}, :name cljs.core/->Reduced, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Reduced, :variadic false, :max-fixed-arity 1}), :line 827, :end-line 827, :max-fixed-arity 1, :fn-var true, :arglists (quote ([val])), :skip-protocol-flag #{cljs.core/IDeref}, :test true}, chunk-buffer {:protocol-inline nil, :name cljs.core/chunk-buffer, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([capacity]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/ChunkBuffer, :variadic false, :max-fixed-arity 1}), :line 2562, :end-line 2562, :max-fixed-arity 1, :fn-var true, :arglists (quote ([capacity])), :test true}, seqable? {:protocol-inline nil, :name cljs.core/seqable?, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1536, :ret-tag boolean, :end-line 1536, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([s])), :doc "Return true if s satisfies ISeqable", :test true}, symbol? {:protocol-inline nil, :name cljs.core/symbol?, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 561, :ret-tag boolean, :end-line 561, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :test true}, m3-hash-unencoded-chars {:protocol-inline nil, :name cljs.core/m3-hash-unencoded-chars, :variadic false, :file "out/cljs/core.cljs", :end-column 39, :method-params ([in]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 479, :ret-tag number, :end-line 479, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([in])), :test true}, unchecked-char {:protocol-inline nil, :name cljs.core/unchecked-char, :variadic false, :file "out/cljs/core.cljs", :end-column 30, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1887, :ret-tag number, :end-line 1887, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x])), :test true}, NeverEquiv {:num-fields 0, :protocols #{cljs.core/IEquiv cljs.core/Object}, :name cljs.core/NeverEquiv, :file "out/cljs/core.cljs", :end-column 21, :type true, :column 10, :line 4879, :record false, :end-line 4879, :skip-protocol-flag #{cljs.core/IEquiv}}, -invoke {:protocol-inline nil, :protocol cljs.core/IFn, :name cljs.core/-invoke, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1} {:tag any, :variadic false, :max-fixed-arity 2} {:tag any, :variadic false, :max-fixed-arity 3} {:tag any, :variadic false, :max-fixed-arity 4} {:tag any, :variadic false, :max-fixed-arity 5} {:tag any, :variadic false, :max-fixed-arity 6} {:tag any, :variadic false, :max-fixed-arity 7} {:tag any, :variadic false, :max-fixed-arity 8} {:tag any, :variadic false, :max-fixed-arity 9} {:tag any, :variadic false, :max-fixed-arity 10} {:tag any, :variadic false, :max-fixed-arity 11} {:tag any, :variadic false, :max-fixed-arity 12} {:tag any, :variadic false, :max-fixed-arity 13} {:tag any, :variadic false, :max-fixed-arity 14} {:tag any, :variadic false, :max-fixed-arity 15} {:tag any, :variadic false, :max-fixed-arity 16} {:tag any, :variadic false, :max-fixed-arity 17} {:tag any, :variadic false, :max-fixed-arity 18} {:tag any, :variadic false, :max-fixed-arity 19} {:tag any, :variadic false, :max-fixed-arity 20} {:tag any, :variadic false, :max-fixed-arity 21} {:tag any, :variadic false, :max-fixed-arity 22}), :line 219, :end-line 220, :max-fixed-arity 22, :fn-var true, :arglists (quote ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest])), :test true}, coll? {:protocol-inline nil, :name cljs.core/coll?, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1437, :ret-tag boolean, :end-line 1437, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x satisfies ICollection", :test true}, get-in {:protocol-inline nil, :added "1.2", :name cljs.core/get-in, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :static true, :method-params ([m ks] [m ks not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:variadic false, :max-fixed-arity 3}), :line 3982, :end-line 3982, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m ks] [m ks not-found])), :doc "Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key is not present,\n  or the not-found value if supplied.", :test true}, fnext {:protocol-inline nil, :name cljs.core/fnext, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 1095, :end-line 1095, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (first (next x))", :test true}, IList {:protocol-symbol true, :name cljs.core/IList, :file "out/cljs/core.cljs", :end-column 20, :column 1, :line 327, :protocol-info {:methods {}}, :info nil, :end-line 327, :impls #{cljs.core/Cons cljs.core/EmptyList cljs.core/List}, :test true}, List {:num-fields 5, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/List, :file "out/cljs/core.cljs", :end-column 15, :type true, :column 10, :line 2199, :record false, :declared true, :end-line 2199, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, -val {:protocol-inline nil, :protocol cljs.core/IMapEntry, :name cljs.core/-val, :variadic false, :file "out/cljs/core.cljs", :end-column 9, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 283, :end-line 285, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, bytes {:protocol-inline nil, :name cljs.core/bytes, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1990, :end-line 1990, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, ->ObjMap {:protocol-inline nil, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/->ObjMap, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([meta keys strobj update-count __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ObjMap, :variadic false, :max-fixed-arity 5}), :line 4948, :end-line 4948, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta keys strobj update-count __hash])), :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :test true}, compare-symbols {:protocol-inline nil, :private true, :name cljs.core/compare-symbols, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any number}, :variadic false, :max-fixed-arity 2}), :line 569, :end-line 569, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b])), :test true}, -seq {:protocol-inline nil, :protocol cljs.core/ISeqable, :name cljs.core/-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 321, :ret-tag clj-or-nil, :end-line 322, :max-fixed-arity 1, :tag clj-or-nil, :fn-var true, :arglists (quote ([o])), :test true}}, :name cljs.core, :doc nil, :excludes #{}, :use-macros nil, :require-macros nil, :uses nil, :requires {StringBuffer goog.string.StringBuffer, garray goog.array, goog.array goog.array, gobject goog.object, goog.object goog.object, goog.string goog.string, gstring goog.string}, :imports {StringBuffer goog.string.StringBuffer}}